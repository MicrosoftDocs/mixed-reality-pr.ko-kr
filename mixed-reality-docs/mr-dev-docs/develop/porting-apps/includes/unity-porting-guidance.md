---
ms.openlocfilehash: 0ef22142ac2efc3ef47ece2619d31dbeddcff8fe
ms.sourcegitcommit: a1bb77f729ee2e0b3dbd1c2c837bb7614ba7b9bd
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/14/2021
ms.locfileid: "98192668"
---
# <a name="project-settings"></a>[<span data-ttu-id="79db4-101">프로젝트 설정</span><span class="sxs-lookup"><span data-stu-id="79db4-101">Project settings</span></span>](#tab/project)

### <a name="1-review-the-common-porting-steps-listed-above"></a><span data-ttu-id="79db4-102">1. 위에 나열 된 일반적인 포팅 단계를 검토 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-102">1. Review the common porting steps listed above</span></span>

<span data-ttu-id="79db4-103">위에 나열 된 일반적인 단계를 검토 하 여 개발 환경이 올바르게 설정 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-103">Review the common steps listed above to make sure your development environment is set up correctly.</span></span> <span data-ttu-id="79db4-104">#3 단계에서 Visual Studio를 사용 하는 경우 Unity 워크 로드를 사용 하 여 **게임 개발** 을 선택 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-104">In step #3, if you're using Visual Studio you should select the **Game Development with Unity** workload.</span></span> <span data-ttu-id="79db4-105">다음 단계에서 최신 버전의 Unity를 설치 하기 때문에 "Unity 편집기 옵션" 구성 요소를 선택 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-105">You may deselect the "Unity Editor optional" component since you'll be installing a newer version of Unity in the next step.</span></span>

### <a name="2-upgrade-to-the-latest-public-build-of-unity-with-windows-mr-support"></a><span data-ttu-id="79db4-106">2. Windows MR 지원을 통해 Unity의 최신 공용 빌드로 업그레이드</span><span class="sxs-lookup"><span data-stu-id="79db4-106">2. Upgrade to the latest public build of Unity with Windows MR Support</span></span>
1. <span data-ttu-id="79db4-107">혼합 현실 지원을 통해 [Unity의 최신 권장 공용 빌드](../../install-the-tools.md) 를 다운로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-107">Download the latest [recommended public build of Unity](../../install-the-tools.md) with mixed reality support.</span></span>
2. <span data-ttu-id="79db4-108">시작 하기 전에 프로젝트 복사본 저장</span><span class="sxs-lookup"><span data-stu-id="79db4-108">Save a copy of your project before you get started</span></span>
3. <span data-ttu-id="79db4-109">프로젝트가 이전 버전의 Unity에서 빌드된 경우에는 Unity에서 제공 되는 [설명서](https://docs.unity3d.com/Manual/UpgradeGuides.html) 를 검토 하세요.</span><span class="sxs-lookup"><span data-stu-id="79db4-109">Review the [documentation](https://docs.unity3d.com/Manual/UpgradeGuides.html) available from Unity on upgrading if your project was built on an older version of Unity.</span></span>
4. <span data-ttu-id="79db4-110">자동 API 업데이트 프로그램을 사용 하기 위한 Unity 사이트의 [지침](https://docs.unity3d.com/Manual/APIUpdater.html) 을 따르세요.</span><span class="sxs-lookup"><span data-stu-id="79db4-110">Follow the [instructions](https://docs.unity3d.com/Manual/APIUpdater.html) on Unity's site for using their automatic API updater</span></span>
5. <span data-ttu-id="79db4-111">프로젝트를 실행 하기 위해 수행 해야 하는 추가 변경 내용이 있는지 확인 하 고 나머지 오류와 경고를 사용 하 여 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-111">Check and see if there are additional changes that you need to make to get your project running, and work through any remaining errors and warnings.</span></span> 

> [!Note] 
> <span data-ttu-id="79db4-112">사용자가 사용 하는 미들웨어가 있는 경우 최신 릴리스를 사용 하 고 있는지 확인 합니다 (아래 3 단계에서 자세한 내용 참조).</span><span class="sxs-lookup"><span data-stu-id="79db4-112">If you have middleware that you depend on, check that you're using the latest release (more details in step 3 below).</span></span>

### <a name="3-upgrade-your-middleware-to-the-latest-versions"></a><span data-ttu-id="79db4-113">3. 미들웨어를 최신 버전으로 업그레이드</span><span class="sxs-lookup"><span data-stu-id="79db4-113">3. Upgrade your middleware to the latest versions</span></span>

<span data-ttu-id="79db4-114">모든 Unity 업데이트를 사용 하 여 게임 또는 응용 프로그램이 종속 된 하나 이상의 미들웨어 패키지를 업데이트 해야 할 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-114">With any Unity update, there's a good chance that you'll need to update one or more middleware packages that your game or application depends on.</span></span> <span data-ttu-id="79db4-115">또한 최신 미들웨어를 최신 상태로 유지 하면 이식 프로세스의 나머지 부분에서 성공 가능성이 높아집니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-115">Additionally, being up to date with the latest middleware increases the likelihood of success throughout the rest of the porting process.</span></span>

### <a name="4-target-your-application-to-run-on-win32"></a><span data-ttu-id="79db4-116">4. Win32에서 실행할 응용 프로그램을 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-116">4. Target your application to run on Win32</span></span>

<span data-ttu-id="79db4-117">Unity 응용 프로그램 내에서:</span><span class="sxs-lookup"><span data-stu-id="79db4-117">From inside your Unity application:</span></span>

* <span data-ttu-id="79db4-118">파일-> 빌드 설정으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-118">Navigate to File -> Build Settings</span></span>
* <span data-ttu-id="79db4-119">"PC, Mac, Linux 독립 실행형"을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-119">Select "PC, Mac, Linux Standalone"</span></span>
* <span data-ttu-id="79db4-120">대상 플랫폼을 "Windows"로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-120">Set target platform to "Windows"</span></span>
* <span data-ttu-id="79db4-121">아키텍처를 "x86" 선택 "플랫폼 전환"으로 설정</span><span class="sxs-lookup"><span data-stu-id="79db4-121">Set architecture to "x86" Select "Switch Platform"</span></span>

> [!NOTE] 
> <span data-ttu-id="79db4-122">응용 프로그램에 스트림에서의 match와 같은 장치 관련 서비스에 대 한 종속성이 있는 경우이 단계에서 사용 하지 않도록 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-122">If your application has any dependencies on device-specific services, such as match making from Steam, you'll need to disable them at this step.</span></span> <span data-ttu-id="79db4-123">Windows에서 나중에 제공 하는 것과 동일한 서비스에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-123">You can hook up to the equivalent services that Windows provides later on.</span></span>

### <a name="5-setup-your-windows-mixed-reality-hardware"></a><span data-ttu-id="79db4-124">5. Windows Mixed Reality 하드웨어 설정</span><span class="sxs-lookup"><span data-stu-id="79db4-124">5. Setup your Windows Mixed Reality hardware</span></span>
1. <span data-ttu-id="79db4-125">[모던 헤드셋 설정](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/before-you-start
) 의 단계 검토</span><span class="sxs-lookup"><span data-stu-id="79db4-125">Review steps in [Immersive headset setup](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/before-you-start
)</span></span>
2. <span data-ttu-id="79db4-126">[Windows Mixed reality 시뮬레이터를 사용 하](../../platform-capabilities-and-apis/using-the-windows-mixed-reality-simulator.md) 고 [windows mixed Reality 홈을 탐색](../../../discover/navigating-the-windows-mixed-reality-home.md) 하는 방법을 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-126">Learn about [Using the Windows Mixed Reality simulator](../../platform-capabilities-and-apis/using-the-windows-mixed-reality-simulator.md) and [Navigating the Windows Mixed Reality home](../../../discover/navigating-the-windows-mixed-reality-home.md)</span></span>

### <a name="6-target-your-application-to-run-on-windows-mixed-reality"></a><span data-ttu-id="79db4-127">6. Windows Mixed Reality에서 실행할 응용 프로그램을 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-127">6. Target your application to run on Windows Mixed Reality</span></span>
1. <span data-ttu-id="79db4-128">먼저 특정 VR SDK와 관련 된 다른 모든 라이브러리 지원을 제거 하거나 조건부로 컴파일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-128">First, you must remove or conditionally compile out any other library support specific to a particular VR SDK.</span></span> <span data-ttu-id="79db4-129">이러한 자산은 Windows Mixed Reality와 같이 다른 VR Sdk와 호환 되지 않는 방식으로 프로젝트의 설정 및 속성을 변경 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-129">Those assets frequently change settings and properties on your project in ways that are incompatible with other VR SDKs, such as Windows Mixed Reality.</span></span>
    * <span data-ttu-id="79db4-130">예를 들어 프로젝트가 SteamVR SDK를 참조 하는 경우 Windows Mixed Reality와 SteamVR를 모두 지 원하는 Unity의 일반적인 VR Api를 대신 사용 하도록 프로젝트를 업데이트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-130">For example, if your project references the SteamVR SDK, you'll need to update your project to instead use Unity's common VR APIs that support both Windows Mixed Reality and SteamVR.</span></span>
    * <span data-ttu-id="79db4-131">다른 VR Sdk를 조건부로 제외 하기 위한 구체적인 단계는 곧 제공 될 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-131">Specific steps for conditionally excluding other VR SDKs are coming soon.</span></span>
2. <span data-ttu-id="79db4-132">Unity 프로젝트에서 [Windows 10 SDK를 대상으로 합니다](../../unity/tutorials/holograms-100.md#target-windows-10-sdk) .</span><span class="sxs-lookup"><span data-stu-id="79db4-132">In your Unity project, [target the Windows 10 SDK](../../unity/tutorials/holograms-100.md#target-windows-10-sdk)</span></span>
3. <span data-ttu-id="79db4-133">각 장면에 대해 [카메라를 설정 합니다](../../unity/tutorials/holograms-100.md#chapter-2---setup-the-camera) .</span><span class="sxs-lookup"><span data-stu-id="79db4-133">For each scene, [setup the camera](../../unity/tutorials/holograms-100.md#chapter-2---setup-the-camera)</span></span>

### <a name="7-use-the-stage-to-place-content-on-the-floor"></a><span data-ttu-id="79db4-134">7. 스테이지를 사용 하 여 바닥에 콘텐츠를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-134">7. Use the stage to place content on the floor</span></span>

<span data-ttu-id="79db4-135">광범위 한 [환경 규모](../../../design/coordinate-systems.md)에서 혼합 현실 환경을 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-135">You can build Mixed Reality experiences across a wide range of [experience scales](../../../design/coordinate-systems.md).</span></span>

<span data-ttu-id="79db4-136">통합 된 **환경을** 이식 하는 경우 Unity가 **고정** 된 추적 공간 종류로 설정 되었는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-136">If you're porting a **seated-scale experience**, you must ensure Unity is set to the **Stationary** tracking space type:</span></span>

```cs
XRDevice.SetTrackingSpaceType(TrackingSpaceType.Stationary);
```

<span data-ttu-id="79db4-137">위의 코드는 Unity의 세계 좌표계를 설정 하 여 [고정 된 참조 프레임](../../../design/coordinate-systems.md#spatial-coordinate-systems)을 추적 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-137">This above code sets Unity's world coordinate system to track the [stationary frame of reference](../../../design/coordinate-systems.md#spatial-coordinate-systems).</span></span> <span data-ttu-id="79db4-138">고정 된 추적 모드에서 카메라의 기본 위치 바로 앞에 있는 편집기에 배치 된 콘텐츠 (앞으로-Z)는 앱이 시작 될 때 사용자 앞에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-138">In the Stationary tracking mode, content placed in the editor just in front of the camera's default location (forward is -Z) appears in front of the user when the app launches.</span></span> <span data-ttu-id="79db4-139">사용자가 연결 된 원본을 recenter Unity의 XR를 호출할 수 있습니다 [. Recenter 메서드입니다.](https://docs.unity3d.com/ScriptReference/XR.InputTracking.Recenter.html)</span><span class="sxs-lookup"><span data-stu-id="79db4-139">To recenter the user's seated origin, you can call Unity's [XR.InputTracking.Recenter](https://docs.unity3d.com/ScriptReference/XR.InputTracking.Recenter.html) method.</span></span>

<span data-ttu-id="79db4-140">**대규모 환경이** 나 **공간 규모의 경험** 을 이식 하는 경우 층에 상대적인 콘텐츠를 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-140">If you're porting a **standing-scale experience** or **room-scale experience**, you'll be placing content relative to the floor.</span></span> <span data-ttu-id="79db4-141">사용자의 층을 사용 하는 이유는 사용자의 정의 된 최고 수준 원점 및 선택적 대화방 경계를 나타내는 **[공간 단계](../../../design/coordinate-systems.md#spatial-coordinate-systems)** 를 처음 실행 하는 동안 설정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-141">You reason about the user's floor using the **[spatial stage](../../../design/coordinate-systems.md#spatial-coordinate-systems)**, which represents the user's defined floor-level origin and optional room boundary, set up during first run.</span></span> <span data-ttu-id="79db4-142">이러한 환경에서는 Unity가 **RoomScale** 추적 공간 형식으로 설정 되어 있는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-142">For these experiences, you must ensure Unity is set to the **RoomScale** tracking space type.</span></span> <span data-ttu-id="79db4-143">RoomScale가 기본값 이지만, 사용자가 보정 한 방에서 컴퓨터를 이동 하는 경우를 명시적으로 설정 하 고 true로 설정 하 여 사용자가 컴퓨터를 이동 하는 경우를 확인 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-143">While RoomScale is the default, you'll want to set it explicitly and ensure you get back true, to catch situations where the user has moved their computer away from the room they calibrated:</span></span>

```cs
if (XRDevice.SetTrackingSpaceType(TrackingSpaceType.RoomScale))
{
    // RoomScale mode was set successfully.  App can now assume that y=0 in Unity world coordinate represents the floor.
}
else
{
    // RoomScale mode was not set successfully.  App cannot make assumptions about where the floor plane is.
}
```

<span data-ttu-id="79db4-144">앱이 RoomScale 추적 공간 유형을 성공적으로 설정 하면 y = 0 평면에 배치 된 콘텐츠가 바닥에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-144">Once your app successfully sets the RoomScale tracking space type, content placed on the y=0 plane will appear on the floor.</span></span> <span data-ttu-id="79db4-145">(0, 0, 0)의 원점은 사용자가 대화방을 설치 하는 동안 구현 하는 바닥의 특정 위치가 되며,-Z는 설치 중에 전달 된 정방향 방향을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-145">The origin at (0, 0, 0) will be the specific place on the floor where the user stood during room setup, with -Z representing the forward direction they were facing during setup.</span></span>

<span data-ttu-id="79db4-146">그런 다음 스크립트 코드에서 TryGetGeometry 메서드를 호출할 수 있습니다. XR 형식으로 경계 다각형을 가져오고 TrackedArea 경계 형식을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-146">In script code, you can then call the TryGetGeometry method on you're the UnityEngine.Experimental.XR.Boundary type to get a boundary polygon, specifying a boundary type of TrackedArea.</span></span> <span data-ttu-id="79db4-147">사용자가 경계를 정의 하는 경우 (꼭 짓 점 목록 다시 표시) 사용자에 게 **공간 확장 환경을** 제공 하 여 사용자가 만든 장면을 탐색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-147">If the user defined a boundary (you get back a list of vertices), it's safe to deliver a **room-scale experience** to the user, where they can walk around the scene you create.</span></span>

<span data-ttu-id="79db4-148">사용자가 접근 하면 시스템에서 자동으로 경계를 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-148">The system will automatically render the boundary when the user approaches it.</span></span> <span data-ttu-id="79db4-149">앱은 경계 자체를 렌더링 하기 위해이 다각형을 사용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-149">Your app does not need to use this polygon to render the boundary itself.</span></span>

<span data-ttu-id="79db4-150">자세한 내용은 [Unity의 좌표계](../../unity/coordinate-systems-in-unity.md) 페이지를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="79db4-150">For more information, see the [Coordinate systems in Unity](../../unity/coordinate-systems-in-unity.md) page.</span></span>

<!-- Some applications use a rectangle to constrain their interaction. Retrieving the largest inscribed rectangle is not directly supported in the UWP API or Unity. The example code linked to below shows how to find a rectangle within the traced bounds. It's heuristic-based so may not find the optimal solution, however, results are consistent with expectations. Parameters in the algorithm can be tuned to find more precise results at the cost of processing time. The algorithm is in a fork of the Mixed Reality Toolkit that uses the 5.6 preview MRTP version of Unity. This isn't publicly available. The code should be directly usable in 2017.2 and higher versions of Unity. The code will be ported to the current MRTK in the near future. -->

<span data-ttu-id="79db4-151">결과의 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-151">Example of results:</span></span>

![결과 예제](../../porting-apps/images/largestrectangle-400px.jpg)

<span data-ttu-id="79db4-153">알고리즘은 Daniel Smilkov의 블로그를 기반으로 합니다. [다각형의 가장 큰 사각형](https://d3plus.org/blog/behind-the-scenes/2014/07/08/largest-rect/)</span><span class="sxs-lookup"><span data-stu-id="79db4-153">Algorithm is based on a blog by Daniel Smilkov: [Largest rectangle in a polygon](https://d3plus.org/blog/behind-the-scenes/2014/07/08/largest-rect/)</span></span>

### <a name="8-work-through-your-input-model"></a><span data-ttu-id="79db4-154">8. 입력 모델을 통해 작업</span><span class="sxs-lookup"><span data-stu-id="79db4-154">8. Work through your input model</span></span>

<span data-ttu-id="79db4-155">기존 HMD를 대상으로 하는 각 게임 또는 응용 프로그램에는 처리 하는 일련의 입력, 환경에 필요한 입력 형식 및 해당 입력을 가져오기 위해 호출 하는 특정 Api가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-155">Each game or application targeting an existing HMD will have a set of inputs that it handles, types of inputs that it needs for the experience, and specific APIs that it calls to get those inputs.</span></span> <span data-ttu-id="79db4-156">Windows Mixed Reality에서 제공 되는 입력을 활용할 수 있도록 간단 하 고 간단 하 게 만드는 데 투자 했습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-156">We've invested in trying to make it as simple and straightforward as possible to take advantage of the inputs available in Windows Mixed Reality.</span></span>

<span data-ttu-id="79db4-157">Windows Mixed Reality에서 입력을 노출 하는 방법 및 응용 프로그램의 용도에 매핑되는 방법에 대 한 자세한 내용은 인접 탭의 [Unity에 대 한 입력 포팅 가이드](https://docs.microsoft.com/windows/mixed-reality/develop/porting-apps/porting-guides?tabs=input) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="79db4-157">Read through the [input porting guide for Unity](https://docs.microsoft.com/windows/mixed-reality/develop/porting-apps/porting-guides?tabs=input) in the adjacent tab for details of how Windows Mixed Reality exposes input, and how that maps to what your application may do today.</span></span>

### <a name="9-performance-testing-and-tuning"></a><span data-ttu-id="79db4-158">9. 성능 테스트 및 튜닝</span><span class="sxs-lookup"><span data-stu-id="79db4-158">9. Performance testing and tuning</span></span>

<span data-ttu-id="79db4-159">Windows Mixed Reality는 하이엔드 게임 Pc부터 광범위 한 시장 메인스트림 Pc까지 광범위 한 장치 클래스에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-159">Windows Mixed Reality will be available on a broad class of devices, ranging from high end gaming PCs, down to broad market mainstream PCs.</span></span> <span data-ttu-id="79db4-160">대상으로 지정 하는 시장에 따라 응용 프로그램에 사용할 수 있는 계산 및 그래픽 예산에 상당한 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-160">Depending on what market you're targeting, there's a significant difference in the available compute and graphics budgets for your application.</span></span> <span data-ttu-id="79db4-161">이 포팅 연습을 수행 하는 동안 프리미엄 PC를 활용 하 고 앱에 사용할 수 있는 중요 한 계산 및 그래픽 예산이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-161">During this porting exercise, you're likely leveraging a premium PC, and have had significant compute and graphics budgets available to your app.</span></span> <span data-ttu-id="79db4-162">앱을 더 광범위 한 사용자가 사용할 수 있도록 하려는 경우 [대상으로 지정 하려는 대표 하드웨어](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)에서 앱을 테스트 하 고 프로 파일링 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-162">If you wish to make your app available to a broader audience, you should test and profile your app on [the representative hardware that you wish to target](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).</span></span>

<span data-ttu-id="79db4-163">[Unity](https://docs.unity3d.com/Manual/Profiler.html) 및 [Visual Studio](https://docs.microsoft.com/visualstudio/profiling/index) 에는 성능 프로파일러가 포함 되며, [Microsoft](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) 및 [Intel](https://software.intel.com/articles/vr-content-developer-guide) 은 성능 프로 파일링 및 최적화에 대 한 지침을 게시 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-163">Both [Unity](https://docs.unity3d.com/Manual/Profiler.html) and [Visual Studio](https://docs.microsoft.com/visualstudio/profiling/index) include performance profilers, and both [Microsoft](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) and [Intel](https://software.intel.com/articles/vr-content-developer-guide) publish guidelines on performance profiling and optimization.</span></span> <span data-ttu-id="79db4-164">[혼합 현실 성능을 이해](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md)하는 데 사용할 수 있는 성능에 대 한 광범위 한 설명이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-164">There's an extensive discussion of performance available at [Understanding Performance for Mixed Reality](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md).</span></span> <span data-ttu-id="79db4-165">Unity에 [대 한 성능 권장 사항](../../unity/performance-recommendations-for-unity.md)에서 unity에 대 한 구체적인 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-165">Further, there are specific details for Unity under [Performance Recommendations for Unity](../../unity/performance-recommendations-for-unity.md).</span></span>

# <a name="input-mapping"></a>[<span data-ttu-id="79db4-166">입력 매핑</span><span class="sxs-lookup"><span data-stu-id="79db4-166">Input mapping</span></span>](#tab/input)

<span data-ttu-id="79db4-167">Unity의 일반 입력의 두 방법 중 하나를 사용 하 여 입력 논리를 Windows Mixed Reality로 이식할 수 있습니다. 여러 플랫폼에 걸쳐 있는 GetButton/Getbutton Api 또는 Windows 별 XR. WSA. 동작 컨트롤러 및 HoloLens 바늘에 대해 구체적으로 다양 한 데이터를 제공 하는 입력 Api</span><span class="sxs-lookup"><span data-stu-id="79db4-167">You can port your input logic to Windows Mixed Reality using one of two approaches, Unity's general Input.GetButton/GetAxis APIs that span across multiple platforms, or the Windows-specific XR.WSA.Input APIs that offer richer data specifically for motion controllers and HoloLens hands.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="79db4-168">HP 반향 G2 컨트롤러를 사용 하는 경우 추가 입력 매핑 지침은 [이 문서](../../unity/unity-reverb-g2-controllers.md) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="79db4-168">If your using HP Reverb G2 controllers, please refer to [this article](../../unity/unity-reverb-g2-controllers.md) for additional input mapping instructions.</span></span>

## <a name="unity-xr-input-apis"></a><span data-ttu-id="79db4-169">Unity XR 입력 Api</span><span class="sxs-lookup"><span data-stu-id="79db4-169">Unity XR input APIs</span></span>

<span data-ttu-id="79db4-170">새 프로젝트의 경우 처음부터 새 XR 입력 Api를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-170">For new projects, we recommend using the new XR input APIs from the beginning.</span></span> 

<span data-ttu-id="79db4-171">[XR api](https://docs.unity3d.com/Manual/xr_input.html)에 대 한 자세한 내용은 여기에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-171">You can find more information about the [XR APIs here](https://docs.unity3d.com/Manual/xr_input.html).</span></span>

## <a name="inputgetbuttongetaxis-apis"></a><span data-ttu-id="79db4-172">입력. GetButton/Getbutton Api</span><span class="sxs-lookup"><span data-stu-id="79db4-172">Input.GetButton/GetAxis APIs</span></span>

<span data-ttu-id="79db4-173">Unity는 현재 일반 입력을 사용 합니다. GetButton/Input. Getbutton Api를 사용 하 여 [Oculus sdk](https://docs.unity3d.com/Manual/OculusControllers.html) 및 [openvr sdk](https://docs.unity3d.com/Manual/OpenVRControllers.html)의 입력을 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-173">Unity currently uses its general Input.GetButton/Input.GetAxis APIs to expose input for [the Oculus SDK](https://docs.unity3d.com/Manual/OculusControllers.html) and [the OpenVR SDK](https://docs.unity3d.com/Manual/OpenVRControllers.html).</span></span> <span data-ttu-id="79db4-174">앱이 입력에 이러한 Api를 이미 사용 하 고 있는 경우 Windows Mixed Reality에서 동작 컨트롤러를 지원 하기에 가장 쉬운 경로입니다. 입력 관리자에서 단추와 축을 다시 매핑해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-174">If your apps are already using these APIs for input, this is the easiest path for supporting motion controllers in Windows Mixed Reality: you should just need to remap buttons and axes in the Input Manager.</span></span>

<span data-ttu-id="79db4-175">자세한 내용은 [unity 단추/축 매핑 표](../../unity/motion-controllers-in-unity.md#unity-buttonaxis-mapping-table) 및 [일반적인 unity api 개요](../../unity/motion-controllers-in-unity.md#common-unity-apis-inputgetbuttongetaxis)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="79db4-175">For more information, see the [Unity button/axis mapping table](../../unity/motion-controllers-in-unity.md#unity-buttonaxis-mapping-table) and the [overview of the common Unity APIs](../../unity/motion-controllers-in-unity.md#common-unity-apis-inputgetbuttongetaxis).</span></span>

## <a name="windows-specific-xrwsainput-apis"></a><span data-ttu-id="79db4-176">Windows 관련 XR. WSA. 입력 Api</span><span class="sxs-lookup"><span data-stu-id="79db4-176">Windows-specific XR.WSA.Input APIs</span></span>

> [!CAUTION]
> <span data-ttu-id="79db4-177">프로젝트에서 XR를 사용 하는 경우 WSA Api는 향후 Unity 릴리스의 XR SDK에 대 한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-177">If your project is using any of the XR.WSA APIs, these are being phased out in favor of the XR SDK in future Unity releases.</span></span> <span data-ttu-id="79db4-178">새 프로젝트의 경우 처음부터 XR SDK를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-178">For new projects, we recommend using the XR SDK from the beginning.</span></span> <span data-ttu-id="79db4-179">[XR 입력 시스템 및 api](https://docs.unity3d.com/Manual/xr_input.html)에 대 한 자세한 내용은 여기에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-179">You can find more information about the [XR Input system and APIs here](https://docs.unity3d.com/Manual/xr_input.html).</span></span>

<span data-ttu-id="79db4-180">앱에서 각 플랫폼에 대 한 사용자 지정 입력 논리를 이미 빌드하는 경우 **XR** 네임 스페이스에서 Windows 관련 공간 입력 api를 사용 하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-180">If your app already builds custom input logic for each platform, you can choose to use the Windows-specific spatial input APIs under the **UnityEngine.XR.WSA.Input** namespace.</span></span> <span data-ttu-id="79db4-181">이렇게 하면 위치 정확도 나 원본 종류와 같은 추가 정보에 액세스할 수 있으므로 HoloLens와 컨트롤러를 따로 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-181">This lets you access additional information, such as position accuracy or the source kind, letting you tell hands and controllers apart on HoloLens.</span></span>

> [!NOTE]
> <span data-ttu-id="79db4-182">HP 반향 G2 컨트롤러를 사용 하는 경우 InteractionSource를 제외 하 고 모든 입력 Api는 계속 작동 합니다 **. supportsTouchpad** 는 터치 패드 데이터 없이 false를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-182">If you're using HP Reverb G2 controllers, all input APIs will continue to work except for **InteractionSource.supportsTouchpad**, which will return false with no touchpad data.</span></span>

<span data-ttu-id="79db4-183">자세한 내용은 [UnityEngine. XR api 개요](../../unity/motion-controllers-in-unity.md#windows-specific-apis-xrwsainput)를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="79db4-183">For more information, see the [overview of the UnityEngine.XR.WSA.Input APIs](../../unity/motion-controllers-in-unity.md#windows-specific-apis-xrwsainput).</span></span>

## <a name="grip-pose-vs-pointing-pose"></a><span data-ttu-id="79db4-184">그립 포즈 및 포인팅 포즈</span><span class="sxs-lookup"><span data-stu-id="79db4-184">Grip pose vs. pointing pose</span></span>

<span data-ttu-id="79db4-185">Windows Mixed Reality는 다양 한 폼 팩터에서 동작 컨트롤러를 지원 하며, 각 컨트롤러의 디자인이 사용자의 손 위치와 앱이 컨트롤러를 렌더링할 때 사용 해야 하는 자연 스러운 "전달" 방향 간의 관계에 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-185">Windows Mixed Reality supports motion controllers in a variety of form factors, with each controller's design differing in its relationship between the user's hand position and the natural "forward" direction that apps should use for pointing when rendering the controller.</span></span>

<span data-ttu-id="79db4-186">이러한 컨트롤러를 더 잘 나타내기 위해 각 상호 작용 소스에 대해 조사할 수 있는 두 가지 종류의 포즈가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-186">To better represent these controllers, there are two kinds of poses you can investigate for each interaction source:</span></span>

* <span data-ttu-id="79db4-187">HoloLens에서 감지 된 손바닥의 위치 또는 이동 컨트롤러를 보유 하는 야자수의 위치를 나타내는 **그립 포즈** 입니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-187">The **grip pose**, representing the location of either the palm of a hand detected by a HoloLens, or the palm holding a motion controller.</span></span>
    * <span data-ttu-id="79db4-188">모던 헤드셋에서는이 포즈를 사용 하 여 사용자 **의 손을** 나 **사용자의 손으로 보유 한 개체**(예: 소드 또는 포)를 렌더링 하는 데 가장 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-188">On immersive headsets, this pose is best used to render **the user's hand** or **an object held in the user's hand**, such as a sword or gun.</span></span>
    * <span data-ttu-id="79db4-189">**그립 위치**: 컨트롤러를 자연스럽 게 유지 하는 경우 왼쪽 또는 오른쪽으로 조정 하 여 그립 내 위치를 가운데에 맞춥니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-189">The **grip position**: The palm centroid when holding the controller naturally, adjusted left or right to center the position within the grip.</span></span>
    * <span data-ttu-id="79db4-190">**그립 방향 오른쪽 축**: 손 모양 5 손가락 포즈를 형성 하는 손을 완전히 열 때 palm (왼쪽 야자나무에서 오른쪽으로 뒤로)의 광선을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-190">The **grip orientation's Right axis**: When you completely open your hand to form a flat 5-finger pose, the ray that is normal to your palm (forward from left palm, backward from right palm)</span></span>
    * <span data-ttu-id="79db4-191">**그립 방향 전방 축: 핸들** 을 부분적으로 (컨트롤러를 보유 하는 것 처럼) 닫는 경우 비 엄지 손가락으로 형성 된 튜브를 통해 "전달" 하는 광선이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-191">The **grip orientation's Forward axis**: When you close your hand partially (as if holding the controller), the ray that points "forward" through the tube formed by your non-thumb fingers.</span></span>
    * <span data-ttu-id="79db4-192">**그립 방향 up 축**: 오른쪽 및 전방 정의에 의해 암시 된 위쪽 축입니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-192">The **grip orientation's Up axis**: The Up axis implied by the Right and Forward definitions.</span></span>
    * <span data-ttu-id="79db4-193">Unity의 교차 공급 업체 입력 API (XR)를 통해 그립 포즈에 액세스할 수 있습니다 **[. InputTracking](https://docs.unity3d.com/ScriptReference/XR.InputTracking.html). GetLocalPosition/Rotation**) 또는 Windows 특정 API (**sourcestate/Rotation**, 그립 포즈 요청)를 통해</span><span class="sxs-lookup"><span data-stu-id="79db4-193">You can access the grip pose through either Unity's cross-vendor input API (**[XR.InputTracking](https://docs.unity3d.com/ScriptReference/XR.InputTracking.html).GetLocalPosition/Rotation**) or through the Windows-specific API (**sourceState.sourcePose.TryGetPosition/Rotation**, requesting the Grip pose).</span></span>
* <span data-ttu-id="79db4-194">앞에 있는 컨트롤러의 팁을 나타내는 **포인터가 포즈** 입니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-194">The **pointer pose**, representing the tip of the controller pointing forward.</span></span>
    * <span data-ttu-id="79db4-195">이 포즈는 컨트롤러 모델 자체를 렌더링할 때 **UI를 가리킬** 때 raycast에 가장 잘 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-195">This pose is best used to raycast when **pointing at UI** when you are rendering the controller model itself.</span></span>
    * <span data-ttu-id="79db4-196">현재 포인터 포즈는 Windows 관련 API (**Sourcestate/Rotation**, 포인터 포즈 요청)를 통해서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-196">Currently, the pointer pose is available only through the Windows-specific API (**sourceState.sourcePose.TryGetPosition/Rotation**, requesting the Pointer pose).</span></span>

<span data-ttu-id="79db4-197">이러한 포즈 좌표는 모두 Unity 세계 좌표로 표현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="79db4-197">These pose coordinates are all expressed in Unity world coordinates.</span></span>
