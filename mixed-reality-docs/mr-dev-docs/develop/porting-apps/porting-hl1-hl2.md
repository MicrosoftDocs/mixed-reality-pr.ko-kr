---
title: HoloLens(1세대) 앱을 HoloLens 2로 포팅
description: MRTK 버전 2 및 HoloLens 2로 이식하려는 HoloLens(1세대) 및 이전 MRTK 버전에 기존 앱이 있는 개발자를 위해 설계되었습니다.
author: hferrone
ms.author: grbury
ms.date: 12/9/2020
ms.topic: article
ms.localizationpriority: high
keywords: Windows Mixed Reality, 테스트, MRTK, MRTK 버전 2, HoloLens 2, unity, 포팅, HoloLens 1세대, 혼합 현실 헤드셋, windows mixed reality 헤드셋, 가상 현실 헤드셋, 마이그레이션, 모범 사례, ARM
ms.openlocfilehash: ddff4ddff70211a5af38e367e863f81fd5f0c82d
ms.sourcegitcommit: 2bf79eef6a9b845494484f458443ef4f89d7efc0
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/17/2020
ms.locfileid: "97612887"
---
# <a name="porting-hololens-1st-gen-apps-to-hololens-2"></a><span data-ttu-id="2a36b-104">HoloLens(1세대) 앱을 HoloLens 2로 포팅</span><span class="sxs-lookup"><span data-stu-id="2a36b-104">Porting HoloLens (1st Gen) apps to HoloLens 2</span></span>

<span data-ttu-id="2a36b-105">이 가이드는 HoloLens(1세대)용 기존 Unity 애플리케이션이 있는 개발자가 HoloLens 2 디바이스용 애플리케이션을 이식하는 것을 지원하기 위해 고안되었습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-105">This guide is tailored to help developers with an existing Unity application for HoloLens (1st gen) port their application for the HoloLens 2 device.</span></span> <span data-ttu-id="2a36b-106">HoloLens(1세대) Unity 애플리케이션을 HoloLens 2로 포팅하기 위한 핵심 단계에는 4가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-106">There are four key steps to porting a HoloLens (1st gen) Unity application to HoloLens 2.</span></span> 

<span data-ttu-id="2a36b-107">아래 섹션에서는 각 단계에 대한 정보를 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-107">The sections below detail information for each stage:</span></span>

| <span data-ttu-id="2a36b-108">1단계</span><span class="sxs-lookup"><span data-stu-id="2a36b-108">Step 1</span></span> | <span data-ttu-id="2a36b-109">2단계</span><span class="sxs-lookup"><span data-stu-id="2a36b-109">Step 2</span></span> | <span data-ttu-id="2a36b-110">3단계</span><span class="sxs-lookup"><span data-stu-id="2a36b-110">Step 3</span></span> | <span data-ttu-id="2a36b-111">4단계</span><span class="sxs-lookup"><span data-stu-id="2a36b-111">Step 4</span></span> |
|----------|-------------------|-------------------|-------------------|
| ![Visual Studio 로고](../images/visualstudio_logo.png) | ![Unity 로고](../../design/images/logo-unity.png)| ![Unity 아이콘](../unity/images/hololens2_icon.jpg) | ![MRTK 로고](../../design/images/74-12.png) |
| <span data-ttu-id="2a36b-116">최신 도구 다운로드</span><span class="sxs-lookup"><span data-stu-id="2a36b-116">Download latest tools</span></span> | <span data-ttu-id="2a36b-117">Unity 프로젝트 업데이트</span><span class="sxs-lookup"><span data-stu-id="2a36b-117">Update Unity Project</span></span> | <span data-ttu-id="2a36b-118">ARM용 컴파일</span><span class="sxs-lookup"><span data-stu-id="2a36b-118">Compile for ARM</span></span> | <span data-ttu-id="2a36b-119">MRTK v2로 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="2a36b-119">Migrate to MRTK v2</span></span>

## <a name="prerequisites"></a><span data-ttu-id="2a36b-120">필수 조건</span><span class="sxs-lookup"><span data-stu-id="2a36b-120">Prerequisites</span></span>

<span data-ttu-id="2a36b-121">이식 프로세스를 시작하기 전에 소스 제어를 사용하여 애플리케이션의 원래 상태를 스냅샷으로 저장할 것을 **적극 권장합니다**.</span><span class="sxs-lookup"><span data-stu-id="2a36b-121">We **highly recommended** using source control to save a snapshot your applications original state before starting the porting process.</span></span> <span data-ttu-id="2a36b-122">또한 프로세스 중 여러 시점에서 검사점 상태를 *저장* 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-122">Additionally, we recommend *saving* checkpoint states at various times during the process.</span></span> <span data-ttu-id="2a36b-123">원래 애플리케이션의 Unity 인스턴스를 하나 더 사용하면 이식 과정에서 나란히 비교할 수 있기 때문에 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-123">It can also be helpful to have another Unity instance of the original application to compare side by side during the porting process.</span></span> 

> [!NOTE]
> <span data-ttu-id="2a36b-124">포팅하기 전에 Windows Mixed Reality 개발을 위한 최신 도구를 설치했는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-124">Before porting, ensure you have the latest tools installed for Windows Mixed Reality development.</span></span> <span data-ttu-id="2a36b-125">대부분의 기존 HoloLens 개발자의 경우 이 작업을 위해 최신 버전의 Visual Studio 2019로 업데이트하고 적절한 Windows SDK를 설치하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-125">For most existing HoloLens developers, this involves updating to the latest version of Visual Studio 2019 and installing the appropriate Windows SDK.</span></span> <span data-ttu-id="2a36b-126">이어지는 내용에서는 여러 다른 Unity 버전과 MRTK(Mixed Reality Toolkit) 버전 2를 좀 더 자세히 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-126">The content that follows dives further into different Unity versions and the Mixed Reality Toolkit (MRTK) Version 2.</span></span>
>
> <span data-ttu-id="2a36b-127">자세한 내용은 [도구 설치](../install-the-tools.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2a36b-127">For more information, please see [Install the tools](../install-the-tools.md).</span></span>

## <a name="migrate-project-to-the-latest-version-of-unity"></a><span data-ttu-id="2a36b-128">최신 버전의 Unity로 프로젝트 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="2a36b-128">Migrate project to the latest version of Unity</span></span>

<span data-ttu-id="2a36b-129">[MRTK v2](https://github.com/microsoft/MixedRealityToolkit-Unity)를 사용하는 경우 [Unity 2019 LTS](https://unity3d.com/unity/qa/lts-releases)는 Unity 또는 MRTK가 획기적으로 변경되지 않는 가장 적합한 장기적인 지원 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-129">If you're using [MRTK v2](https://github.com/microsoft/MixedRealityToolkit-Unity), [Unity 2019 LTS](https://unity3d.com/unity/qa/lts-releases) is the best long-term support path with no breaking changes in Unity or in MRTK.</span></span> <span data-ttu-id="2a36b-130">프로젝트에 현재 존재하는 [플러그 인 종속성](https://docs.unity3d.com/Manual/Plugins.html)을 평가하고 해당 DLL을 ARM64용으로 빌드할 수 있는지 여부를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="2a36b-130">Assess any [plugin dependencies](https://docs.unity3d.com/Manual/Plugins.html) that currently exist in your project, and determine whether these DLLs can be built for ARM64.</span></span> <span data-ttu-id="2a36b-131">하드 ARM64 종속 플러그 인을 사용하는 프로젝트의 경우 ARM용 앱을 계속 빌드해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-131">For projects with a hard ARM64 dependent plugin, you may need to continue building your app for ARM.</span></span>

<!-- MRTK v2 always guarantees support for Unity 2018 LTS, but does not necessarily guarantee support for every iteration of Unity 2019.x.

To help clarify additional differences between [Unity 2018 LTS](https://unity3d.com/unity/qa/lts-releases) and Unity 2019.x, the following table outlines the trade-offs between the two versions. The primary difference between the two is the ability to compile for ARM64 in Unity 2019.

| Unity 2018 LTS | Unity 2019.x |
|----------|-------------------|
| ARM32 build support | ARM32 and ARM64 build support |
| Stable LTS build release | Beta stability |
| [.NET Scripting back-end](https://docs.unity3d.com/2018.4/Documentation/Manual/windowsstore-dotnet.html) *deprecated* | [.NET Scripting back-end](https://docs.unity3d.com/2018.4/Documentation/Manual/windowsstore-dotnet.html) *removed* |
| UNET Networking *deprecated* | UNET Networking *deprecated* |

-->

## <a name="update-sceneproject-settings-in-unity"></a><span data-ttu-id="2a36b-132">Unity에서 장면/프로젝트 설정 업데이트</span><span class="sxs-lookup"><span data-stu-id="2a36b-132">Update scene/project settings in Unity</span></span>

<span data-ttu-id="2a36b-133">[Unity 2019 LTS](https://unity3d.com/unity/qa/lts-releases)로 업데이트한 후 디바이스에서 최적의 결과를 얻으려면 Unity에서 특정 설정을 업데이트하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-133">After updating to [Unity 2019 LTS](https://unity3d.com/unity/qa/lts-releases), it's recommended that you update particular settings in Unity for optimal results on the device.</span></span> <span data-ttu-id="2a36b-134">이러한 설정은 [Unity의 권장 설정](../unity/Recommended-settings-for-Unity.md)에 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-134">These settings are outlined in detail under [recommended settings for Unity](../unity/Recommended-settings-for-Unity.md).</span></span>

<span data-ttu-id="2a36b-135">[.NET 스크립팅 백 엔드](https://docs.unity3d.com/Manual/windowsstore-dotnet.html)는 Unity 2018에서 더 이상 사용되지 않으며 Unity 2019에서 **제거** 되었음을 거듭 알려 드립니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-135">To reiterate, the [.NET scripting back-end](https://docs.unity3d.com/Manual/windowsstore-dotnet.html) is being deprecated in Unity 2018 and **removed** in Unity 2019.</span></span> <span data-ttu-id="2a36b-136">개발자는 프로젝트를 [IL2CPP](https://docs.unity3d.com/Manual/IL2CPP.html)로 전환하는 것을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-136">Developers should strongly consider switching their project to [IL2CPP](https://docs.unity3d.com/Manual/IL2CPP.html).</span></span>

> [!NOTE]
> <span data-ttu-id="2a36b-137">IL2CPP 스크립팅 백 엔드로 인해 Unity에서 Visual Studio로의 빌드 시간이 더 오래 걸릴 수 있으므로 개발자는 [IL2CPP 빌드 시간을 최적화](https://docs.unity3d.com/Manual/IL2CPP-OptimizingBuildTimes.html)하도록 개발자 머신을 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-137">IL2CPP scripting back-end can cause longer build times from Unity to Visual Studio, and developers should set up their developer machine for [optimizing IL2CPP build times](https://docs.unity3d.com/Manual/IL2CPP-OptimizingBuildTimes.html).</span></span>
> <span data-ttu-id="2a36b-138">또한 대용량 자산(스크립트 파일 제외) 또는 지속적으로 변화하는 장면 및 자산을 포함하는 Unity 프로젝트에 맞게 [캐시 서버](https://docs.unity3d.com/Manual/CacheServer.html)를 설정하는 것도 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-138">It might also be beneficial to set up a [cache server](https://docs.unity3d.com/Manual/CacheServer.html), especially for Unity projects with a large amount of assets (excluding script files) or constantly changing scenes and assets.</span></span> <span data-ttu-id="2a36b-139">프로젝트를 열 때 Unity는 정식 자산을 개발자 컴퓨터에 내부 캐시 형식으로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-139">When opening a project, Unity stores qualifying assets into an internal cache format on the developer machine.</span></span> <span data-ttu-id="2a36b-140">따라서 항목이 수정되면 다시 가져온 후 다시 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-140">Items must be re-imported and re-processed when modified.</span></span> <span data-ttu-id="2a36b-141">모든 개발자가 새 변경 내용을 로컬로 다시 가져오지 않고, 이 프로세스를 한 번 수행한 후 캐시 서버에 저장하고, 이후에 다른 개발자와 공유할 수 있으므로 시간을 절약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-141">This process can be done once and saved in a cache server and consequently shared with other developers to save time, as opposed to every developer processing the re-import of new changes locally.</span></span>

<span data-ttu-id="2a36b-142">업데이트된 Unity 버전으로 인한 주요 변경 내용을 처리한 다음, HoloLens(1세대)에서 현재 애플리케이션을 빌드하고 테스트하세요.</span><span class="sxs-lookup"><span data-stu-id="2a36b-142">After addressing any breaking changes from moving to the updated Unity version, build and test your current applications on HoloLens (1st gen).</span></span> <span data-ttu-id="2a36b-143">또한 이때 소스 제어에 커밋을 만들고 저장하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-143">This is a good time to create and save a commit into source control.</span></span>

## <a name="compile-dependenciesplugins-for-arm-processor"></a><span data-ttu-id="2a36b-144">ARM 프로세서에 대한 종속성/플러그 인 컴파일</span><span class="sxs-lookup"><span data-stu-id="2a36b-144">Compile dependencies/plugins for ARM processor</span></span>

<span data-ttu-id="2a36b-145">HoloLens(1세대)는 x86 프로세서에서 애플리케이션을 실행하지만, HoloLens 2는 ARM 프로세서를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-145">HoloLens (1st gen) executes applications on an x86 processor while the HoloLens 2 uses an ARM processor.</span></span> <span data-ttu-id="2a36b-146">ARM을 지원하도록 기존 HoloLens 애플리케이션을 이식해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-146">Existing HoloLens applications need to be ported over to support ARM.</span></span> <span data-ttu-id="2a36b-147">앞에서 설명한 대로 Unity 2018 LTS는 ARM32 앱 컴파일을 지원하지만, Unity 2019.x는 ARM32 및 ARM64 앱 컴파일을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-147">As noted earlier, Unity 2018 LTS supports compiling ARM32 apps while Unity 2019.x supports compiling ARM32 and ARM64 apps.</span></span> <span data-ttu-id="2a36b-148">성능에 차이가 있으므로 ARM64 애플리케이션을 개발하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-148">Developing for ARM64 applications is preferred, as there's a material difference in performance.</span></span> <span data-ttu-id="2a36b-149">그러나 이 경우 ARM64에 대해 모든 [플러그 인 종속성](https://docs.unity3d.com/Manual/Plugins.html)도 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-149">However, this requires all [plugin dependencies](https://docs.unity3d.com/Manual/Plugins.html) to also be built for ARM64.</span></span>

<span data-ttu-id="2a36b-150">애플리케이션에서 모든 DLL 종속성을 검토하세요.</span><span class="sxs-lookup"><span data-stu-id="2a36b-150">Review all DLL dependencies in your application.</span></span> <span data-ttu-id="2a36b-151">프로젝트에 더 이상 필요하지 않은 종속성을 제거하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-151">We recommend removing dependencies that are no longer needed for your project.</span></span> <span data-ttu-id="2a36b-152">필요한 나머지 플러그 인의 경우 해당 ARM32 또는 ARM64 이진 파일을 Unity 프로젝트로 수집합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-152">For remaining plugins that are required, ingest the respective ARM32 or ARM64 binaries into your Unity project.</span></span>

<span data-ttu-id="2a36b-153">관련 DLL을 수집한 후에는 Unity에서 Visual Studio 솔루션을 빌드하고 Visual Studio에서 ARM용 AppX를 컴파일하여 ARM 프로세서용으로 애플리케이션을 빌드할 수 있는지 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-153">After ingesting the relevant DLLs, build a Visual Studio solution from Unity and compile an AppX for ARM in Visual Studio to test your application can be built for ARM processors.</span></span> <span data-ttu-id="2a36b-154">소스 제어 솔루션에서 커밋으로 애플리케이션을 저장하는 것도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-154">It's advised to save the application as a commit in your source control solution.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="2a36b-155">MRTK v1을 사용하는 애플리케이션은 빌드 대상을 ARM으로 변경한 후 HoloLens 2에서 실행할 수 있습니다. 단, 다른 모든 요구 사항이 충족되었다고 가정한 경우에 한정됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-155">Application's using MRTK v1 can be run on HoloLens 2 after changing the build target to ARM, assuming that all other requirements are met.</span></span> <span data-ttu-id="2a36b-156">이를 위해 모든 플러그 인의 ARM 버전이 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-156">This includes making sure you have ARM versions of all your plugins.</span></span> <span data-ttu-id="2a36b-157">하지만 앱에서는 HoloLens 2 특정 기능(예: 관절식 손 및 시선 추적)에 액세스할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-157">However, your app won't have access to HoloLens 2 specific functions like articulated hand and eye tracking.</span></span> <span data-ttu-id="2a36b-158">MRTK v1과 MRTK v2는 네임스페이스가 서로 다르기 때문에 두 버전을 같은 프로젝트에 배치할 수 있고, 한 버전에서 다른 버전으로 전환하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-158">MRTK v1 and MRTK v2 have different namespaces that allow both versions to be in the same project, which is useful for transitioning from one to the other.</span></span>

## <a name="update-to-mrtk-version-2"></a><span data-ttu-id="2a36b-159">MRTK 버전 2로 업데이트</span><span class="sxs-lookup"><span data-stu-id="2a36b-159">Update to MRTK version 2</span></span>

<span data-ttu-id="2a36b-160">[MRTK 버전 2](https://github.com/microsoft/MixedRealityToolkit-Unity)는 HoloLens(1세대) 및 HoloLens 2를 모두 지원하는 Unity 기반 새로운 툴킷입니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-160">[MRTK Version 2](https://github.com/microsoft/MixedRealityToolkit-Unity) is the new toolkit on top of Unity that supports both HoloLens (1st gen) and HoloLens 2.</span></span> <span data-ttu-id="2a36b-161">여기에는 새로운 HoloLens 2 기능(예: 손 상호 작용 및 시선 추적)도 추가되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-161">It's also where all the new HoloLens 2 capabilities have been added, such as hand interactions and eye tracking.</span></span>

<span data-ttu-id="2a36b-162">MRTK 버전 2를 사용하는 방법에 대한 자세한 내용은 다음 리소스를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="2a36b-162">Check out the following resources for more information on using MRTK version 2:</span></span>

- [<span data-ttu-id="2a36b-163">MRTK - 설명서 홈(GitHub)</span><span class="sxs-lookup"><span data-stu-id="2a36b-163">MRTK - Documentation home (GitHub)</span></span>](https://microsoft.github.io/MixedRealityToolkit-Unity/README.html)
- [<span data-ttu-id="2a36b-164">설치 가이드(GitHub)</span><span class="sxs-lookup"><span data-stu-id="2a36b-164">Installation guide (GitHub)</span></span>](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Installation.html)
- [<span data-ttu-id="2a36b-165">MRTK - 손 추적(GitHub)</span><span class="sxs-lookup"><span data-stu-id="2a36b-165">MRTK - Hand tracking (GitHub)</span></span>](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Input/HandTracking.html)
- [<span data-ttu-id="2a36b-166">MRTK - 시선 추적(GitHub)</span><span class="sxs-lookup"><span data-stu-id="2a36b-166">MRTK - Eye tracking (GitHub)</span></span>](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/EyeTracking/EyeTracking_Main.html)

### <a name="prepare-for-the-migration"></a><span data-ttu-id="2a36b-167">마이그레이션 준비</span><span class="sxs-lookup"><span data-stu-id="2a36b-167">Prepare for the migration</span></span>

<span data-ttu-id="2a36b-168">새 [MRTK v2용 \*.unitypackage 파일](https://github.com/Microsoft/MixedRealityToolkit-Unity/releases)을 삽입하기 전에 **1) MRTK v1과 통합되는 사용자 지정 코드** 및 **2) 입력 상호 작용 또는 UX 구성 요소에 대한 사용자 지정 코드** 인벤토리를 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-168">Before ingesting the new [\*.unitypackage files for MRTK v2](https://github.com/Microsoft/MixedRealityToolkit-Unity/releases), it's recommended to take an inventory of **1) any custom-built code that integrates with MRTK v1** and **2) any custom-built code for input interactions or UX components**.</span></span> <span data-ttu-id="2a36b-169">MRTK v2를 수집하는 혼합 현실 개발자에게 가장 흔하게 나타나는 충돌은 입력 및 조작과 관련된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-169">The most common and prevalent conflict for a mixed reality developer ingesting MRTK v2 involves input and interactions.</span></span> <span data-ttu-id="2a36b-170">먼저 [MRTK v2 입력 모델](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Input/Overview.html)을 읽고 이해하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-170">It's advised to begin reading and understanding the [MRTK v2 input model](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Input/Overview.html).</span></span>

<span data-ttu-id="2a36b-171">마지막으로, 새 [MRTK v2](https://github.com/microsoft/MixedRealityToolkit-Unity)는 스크립트 및 장면 내 관리자 개체의 모델에서 구성 및 서비스 공급자 아키텍처로 전환되었습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-171">Finally, the new [MRTK v2](https://github.com/microsoft/MixedRealityToolkit-Unity) has transitioned from a model of scripts and in-scene manager objects to a configuration and services provider architecture.</span></span> <span data-ttu-id="2a36b-172">이로 인해 보다 명확한 장면 계층 구조 및 아키텍처 모델이 구현되지만, 새로운 구성 프로필을 이해하기 위한 학습 곡선이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-172">This results in a cleaner scene hierarchy and architecture model, but requires a learning curve for understanding the new configuration profiles.</span></span> <span data-ttu-id="2a36b-173">[Mixed Reality Toolkit 구성 가이드](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/MixedRealityConfigurationGuide.html)를 읽어보고 애플리케이션 요구에 맞게 조정해야 하는 중요한 설정 및 프로필에 익숙해지도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-173">Read the [Mixed Reality Toolkit Configuration Guide](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/MixedRealityConfigurationGuide.html) to start becoming familiar with the important settings and profiles to adjust to the needs of your application.</span></span>

### <a name="migrating-the-project"></a><span data-ttu-id="2a36b-174">프로젝트 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="2a36b-174">Migrating the project</span></span>

<span data-ttu-id="2a36b-175">[MRTK v2](https://github.com/microsoft/MixedRealityToolkit-Unity)를 가져온 후 Unity 프로젝트에 컴파일러 관련 오류가 많이 나타날 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-175">After importing [MRTK v2](https://github.com/microsoft/MixedRealityToolkit-Unity), your Unity project most likely has many compiler-related errors.</span></span> <span data-ttu-id="2a36b-176">이러한 오류가 발생하는 가장 일반적인 이유는 새로운 네임스페이스 구조 및 새로운 구성 요소 이름 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-176">These are commonly because of the new namespace structure and new component names.</span></span> <span data-ttu-id="2a36b-177">새로운 네임스페이스 및 구성 요소에 맞게 스크립트를 수정하여 이러한 오류를 계속 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-177">continue to resolve these errors by modifying your scripts to the new namespaces and components.</span></span>

<span data-ttu-id="2a36b-178">HTK/MRTK와 MRTK v2 간의 특정 API 차이점에 대한 자세한 내용은 [MRTK 버전 2 wiki](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/HTKToMRTKPortingGuide.html)의 포팅 가이드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2a36b-178">For information on the specific API differences between HTK/MRTK and MRTK v2, see the porting guide on the [MRTK Version 2 wiki](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/HTKToMRTKPortingGuide.html).</span></span>

### <a name="best-practices"></a><span data-ttu-id="2a36b-179">모범 사례</span><span class="sxs-lookup"><span data-stu-id="2a36b-179">Best practices</span></span>

- <span data-ttu-id="2a36b-180">기본적으로 [MRTK 표준 셰이더](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-180">Prefer use of the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html).</span></span>
- <span data-ttu-id="2a36b-181">한 번에 한 가지 중요 변경 유형 처리(예: IFocusable에서 [IMixedRealityFocusHandler](https://microsoft.github.io/MixedRealityToolkit-Unity/api/Microsoft.MixedReality.Toolkit.Input.IMixedRealityFocusHandler.html)로의 변경)</span><span class="sxs-lookup"><span data-stu-id="2a36b-181">Work on one breaking change type at a time (ex: IFocusable to [IMixedRealityFocusHandler](https://microsoft.github.io/MixedRealityToolkit-Unity/api/Microsoft.MixedReality.Toolkit.Input.IMixedRealityFocusHandler.html)).</span></span>
- <span data-ttu-id="2a36b-182">변경할 때마다 테스트하고 소스 제어를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-182">Test after every change and use source control.</span></span>
- <span data-ttu-id="2a36b-183">가능한 경우 기본 MRTK UX(단추, 슬레이트 등)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-183">Use default MRTK UX (buttons, slates, and so on), when possible.</span></span>
- <span data-ttu-id="2a36b-184">MRTK 파일을 직접 수정하지 않고, MRTK 구성 요소에 대해 래퍼를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-184">Refrain from modifying MRTK files directly; create wrappers around MRTK components.</span></span>
    - <span data-ttu-id="2a36b-185">그러면 향후 MRTK 삽입 및 업데이트가 편리해집니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-185">This action eases future MRTK ingestions and updates.</span></span>
- <span data-ttu-id="2a36b-186">MRTK에 제공된 샘플 장면(특히 *HandInteractionExamples.scene*)을 검토 및 탐색합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-186">Review and explore sample scenes provided in the MRTK, especially *HandInteractionExamples.scene*.</span></span>
- <span data-ttu-id="2a36b-187">quads, colliders 및 TextMeshPro 텍스트를 사용하여 캔버스 기반 UI를 다시 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-187">Rebuild canvas-based UI with quads, colliders, and TextMeshPro text.</span></span>
- <span data-ttu-id="2a36b-188">[깊이 버퍼 공유](../unity/camera-in-unity.md#sharing-your-depth-buffers-with-windows) 또는 [포커스 포인트 설정](../unity/focus-point-in-unity.md)을 사용하도록 설정합니다. 성능 향상을 위해 16비트 깊이 버퍼를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-188">Enable [Depth Buffer Sharing](../unity/camera-in-unity.md#sharing-your-depth-buffers-with-windows) or [set focus point](../unity/focus-point-in-unity.md); prefer to use a 16-bit depth buffer for better performance.</span></span> <span data-ttu-id="2a36b-189">색을 렌더링할 때 깊이도 렌더링하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-189">Ensure when rendering color, to also render depth.</span></span> <span data-ttu-id="2a36b-190">Unity는 일반적으로 투명 및 텍스트 gameobject에 대한 심도를 작성하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-190">Unity generally doesn't write depth for transparent and text gameobjects.</span></span> 
- <span data-ttu-id="2a36b-191">단일 패스 인스턴스 렌더링 경로를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-191">Set Single Pass Instanced Rendering Path.</span></span>
- <span data-ttu-id="2a36b-192">[MRTK에 대한 HoloLens 2 구성 프로필](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Profiles/Profiles.html#hololens-2-profile) 사용</span><span class="sxs-lookup"><span data-stu-id="2a36b-192">Use the [HoloLens 2 configuration profile for MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Profiles/Profiles.html#hololens-2-profile)</span></span>

### <a name="testing-your-application"></a><span data-ttu-id="2a36b-193">애플리케이션 테스트</span><span class="sxs-lookup"><span data-stu-id="2a36b-193">Testing your application</span></span>

<span data-ttu-id="2a36b-194">MRTK 버전 2에서는 Unity에서 직접 손 상호 작용을 시뮬레이션하고, 손 상호 작용 및 시선 추적을 위한 API를 새로 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-194">In MRTK Version 2, you can simulate hand interactions directly in Unity and develop with the new APIs for hand interactions and eye tracking.</span></span> <span data-ttu-id="2a36b-195">HoloLens 2 디바이스는 만족스러운 사용자 환경을 만드는 데 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-195">The HoloLens 2 device is required to create a satisfying user experience.</span></span> <span data-ttu-id="2a36b-196">더 잘 이해하기 위해 문서와 도구에 대한 연구를 시작하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-196">You're encouraged to start studying the documentation and tools for greater understanding.</span></span> <span data-ttu-id="2a36b-197">[MRTK v2](https://github.com/microsoft/MixedRealityToolkit-Unity)는 HoloLens(1세대)에서의 개발을 지원하며, 에어 탭을 통한 선택과 같은 기존 입력 모델을 HoloLens(1세대)에서 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-197">[MRTK v2](https://github.com/microsoft/MixedRealityToolkit-Unity) supports development on HoloLens (1st gen) and traditional input models, such as select via air-tap can be tested on HoloLens (1st gen).</span></span> 

## <a name="updating-your-interaction-model-for-hololens-2"></a><span data-ttu-id="2a36b-198">HoloLens 2용 조작 모델 업데이트</span><span class="sxs-lookup"><span data-stu-id="2a36b-198">Updating your interaction model for HoloLens 2</span></span>

> [!CAUTION]
> <span data-ttu-id="2a36b-199">프로젝트에서 XR.WSA API를 사용하는 경우 향후 Unity 릴리스에서 Unity의 새로운 XR 입력 API를 위해 이러한 API가 단계적으로 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-199">If your project is using any of the XR.WSA APIs, these are being phased out in favor of Unity's new XR input APIs in future Unity releases.</span></span> <span data-ttu-id="2a36b-200">[XR 입력 API](https://docs.unity3d.com/Manual/xr_input.html)에 대한 자세한 내용은 여기에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-200">You can find more information about the [XR input APIs here](https://docs.unity3d.com/Manual/xr_input.html).</span></span>

<span data-ttu-id="2a36b-201">애플리케이션을 HoloLens 2에 이식하고 준비한 경우 조작 모델 및 홀로그램 디자인 배치를 업데이트할 준비가 된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-201">Once your application is ported and prepped for HoloLens 2, you're ready to consider updating your interaction model and hologram design placements.</span></span>
<span data-ttu-id="2a36b-202">HoloLens(1세대)에서 해당 애플리케이션은 시야각에 맞도록 홀로그램이 비교적 멀리 떨어져 있는 응시 및 커밋 조작 모델을 사용할 확률이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-202">In HoloLens (1st gen), your application likely has a gaze and commit interaction model with holograms relatively far away to fit into the field of view.</span></span>

<span data-ttu-id="2a36b-203">HoloLens 2에 가장 적합하게 애플리케이션 디자인을 업데이트하는 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-203">Steps to update your application design to be best suited for HoloLens 2:</span></span>
1.  <span data-ttu-id="2a36b-204">MRTK 구성 요소: 사전 작업에 따라, [MRTK v2](https://github.com/microsoft/MixedRealityToolkit-Unity)를 추가한 경우 HoloLens 2에 맞게 디자인하고 최적화한 다양한 구성 요소/스크립트를 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-204">MRTK components: Per the pre-work, if you added [MRTK v2](https://github.com/microsoft/MixedRealityToolkit-Unity), there are various components/scripts to leverage that have been designed and optimized for HoloLens 2.</span></span>

2.  <span data-ttu-id="2a36b-205">조작 모델: 조작 모델을 업데이트하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-205">Interaction model: Consider updating your interaction model.</span></span> <span data-ttu-id="2a36b-206">대부분의 시나리오에서는 응시 및 커밋에서 손 조작으로 전환하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-206">For most scenarios, we recommend switching from gaze and commit to hands.</span></span> <span data-ttu-id="2a36b-207">홀로그램이 일반적으로 손에 닿지 않는 경우 손으로 전환하면 원거리 조작 포인팅 광선 및 잡기 제스처가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-207">With your holograms typically being out of arms-reach, switching to hands results in far interaction pointing rays and grab gestures.</span></span>

3.  <span data-ttu-id="2a36b-208">홀로그램 배치: 손 상호 작용 모델로 전환한 후에는 손으로 근거리 상호 작용 잡기 제스처를 사용하여 홀로그램을 좀 더 가깝게 옮겨서 직접 상호 작용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-208">Hologram placement: After switching to a hands interaction model, consider moving some holograms closer to directly interact with them, by using near-interaction grab gestures with your hands.</span></span> <span data-ttu-id="2a36b-209">직접 잡거나 조작하기 위해 좀 더 가깝게 이동하는 것이 바람직한 홀로그램 유형은 홀로그램을 잡고 조작할 때 HoloLens 2 시야각 내에 잘 맞는 작은 대상 메뉴, 컨트롤, 단추 및 더 작은 홀로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-209">The types of holograms recommended to move closer to directly grab or interact are small target menus, controls, buttons, and smaller holograms that fit within the HoloLens 2 field of view when grabbing and inspecting the hologram.</span></span>
<br>
<span data-ttu-id="2a36b-210">모든 애플리케이션 및 시나리오는 다르며, 피드백 및 지속적인 학습을 토대로 디자인 지침을 계속 조정한 후 게시할 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-210">Every application and scenario are different, and we’ll continue to refine and post design guidance based on feedback and continued learnings.</span></span>


## <a name="additional-caveats-and-learnings-about-moving-applications-from-x86-to-arm"></a><span data-ttu-id="2a36b-211">x86에서 ARM으로 애플리케이션을 이동하는 방법에 대한 추가 주의 사항 및 학습</span><span class="sxs-lookup"><span data-stu-id="2a36b-211">Additional caveats and learnings about moving applications from x86 to ARM</span></span>

- <span data-ttu-id="2a36b-212">간단한 Unity 애플리케이션은 ARM 애플리케이션 번들을 빌드하거나 번들이 실행될 수 있도록 디바이스에 직접 배포할 수 있기 때문에 단순합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-212">Straight-forward Unity applications are simple because you can build an ARM application bundle or deploy directly to the device for the bundle to run.</span></span> <span data-ttu-id="2a36b-213">일부 Unity 네이티브 플러그 인은 특정 개발 과제를 제시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-213">Some Unity native plugins can present certain development challenges.</span></span> <span data-ttu-id="2a36b-214">이 때문에 모든 Unity 네이티브 플러그 인을 Visual Studio 2019로 업그레이드한 다음, ARM용으로 다시 구축해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-214">Because of this, you must upgrade all Unity native plugins to Visual Studio 2019 and then rebuild for ARM.</span></span>

- <span data-ttu-id="2a36b-215">한 애플리케이션은 Unity AudioKinetic Wwise 플러그 인을 사용했으며, 해당 Unity 버전에 UWP ARM 플러그 인이 없었으므로 ARM에서 실행하기 위해 해당 애플리케이션으로 사운드 기능을 재작업하는 데 상당한 노력이 필요했습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-215">One application used the Unity AudioKinetic Wwise plugin and that version of Unity didn't have a UWP ARM plugin, which caused a considerable effort to rework sound capabilities into the application in question to run on ARM.</span></span> <span data-ttu-id="2a36b-216">개발 계획에 필요한 모든 플러그 인이 Unity에 설치되어 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-216">Ensure that all required plugins for your development plans are installed and available in Unity.</span></span>

- <span data-ttu-id="2a36b-217">일부 경우, 애플리케이션에 필요한 플러그 인에 UWP/ARM 플러그 인이 없을 수 있으며, 이 플러그 인은 애플리케이션을 HoloLens 2에서 이식하고 실행할 수 있는 기능을 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-217">In some cases, a UWP/ARM plugin might not exist for application-required plugins, which blocks the ability to port the application and run it on HoloLens 2.</span></span> <span data-ttu-id="2a36b-218">문제를 해결하고 ARM에 대한 지원을 제공하려면 플러그 인 공급 기업에게 문의하세요.</span><span class="sxs-lookup"><span data-stu-id="2a36b-218">Contact your plugin provider to resolve the issue and provide support for ARM.</span></span>

- <span data-ttu-id="2a36b-219">셰이더의 minfloat(및 min16float, minint 등의 변형)는 HoloLens 2에서 HoloLens(1세대)와는 다르게 동작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-219">The minfloat (and variants such as min16float, minint, and so on) in shaders might behave differently on HoloLens 2 than on HoloLens (1st gen).</span></span> <span data-ttu-id="2a36b-220">특히, 적어도 지정된 수의 비트가 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-220">Specifically, these guarantee that at least the specified number of bits will be used.</span></span> <span data-ttu-id="2a36b-221">Intel/Nvidia GPU에서 minfloat는 대체적으로 32비트로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-221">On Intel/Nvidia GPUs, minfloats are largely treated as 32 bits.</span></span> <span data-ttu-id="2a36b-222">ARM에서는 지정된 비트 수가 실제로 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-222">On ARM, the number of bits specified is actually adhered to.</span></span> <span data-ttu-id="2a36b-223">즉, 실제로 이러한 수는 HoloLens(1세대)의 경우보다 HoloLens 2에서 전체 자릿수 또는 범위가 더 적을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-223">That means in practice, these numbers might have less precision or range on HoloLens 2 than they did on HoloLens (1st gen).</span></span>

- <span data-ttu-id="2a36b-224">_asm 명령은 ARM에서 작동하지 않는 것처럼 나타납니다. 즉, _asm 명령을 사용하는 모든 코드는 다시 작성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-224">The _asm instructions don’t appear to work on ARM, meaning any code using _asm instructions must be rewritten.</span></span>

- <span data-ttu-id="2a36b-225">xmmintrin.h, emmintrin.h, tmmintrin.h 및 immintrin.h와 같은 다양한 헤더를 ARM에서 사용할 수 없으므로 SIMD 명령 세트는 ARM에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-225">ARM doesn't support the SIMD instruction set because various headers, such as xmmintrin.h, emmintrin.h, tmmintrin.h, and immintrin.h, aren't available on ARM.</span></span>

- <span data-ttu-id="2a36b-226">ARM의 셰이더 컴파일러는 셰이더 로드 타임이 아니라, 셰이더가 로드되었거나 셰이더가 의존하는 대상이 변경된 이후의 첫 번째 그리기 호출 동안 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-226">The shader compiler on ARM runs during the first draw call after the shader has been loaded or something the shader relies on has changed, not at shader load time.</span></span> <span data-ttu-id="2a36b-227">프레임 속도에 미치는 영향은 컴파일해야 하는 셰이더 수에 따라 눈에 띄게 달라질 수 있으며, 셰이더 처리, 패키징, 업데이트 방법에 미치는 영향은 HoloLens 2와 HoloLens(1세대)에서 서로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="2a36b-227">The impact on framerate can be noticeable, depending on how many shaders need to be compiled, with implications for how shaders should be handled, packaged, updated differently on HoloLens 2 vs HoloLens (1st gen).</span></span>

## <a name="see-also"></a><span data-ttu-id="2a36b-228">참고 항목</span><span class="sxs-lookup"><span data-stu-id="2a36b-228">See also</span></span>
* [<span data-ttu-id="2a36b-229">도구 설치</span><span class="sxs-lookup"><span data-stu-id="2a36b-229">Install the tools</span></span>](../install-the-tools.md)
* [<span data-ttu-id="2a36b-230">MRTK - 설치 가이드(GitHub)</span><span class="sxs-lookup"><span data-stu-id="2a36b-230">MRTK - Installation guide (GitHub)</span></span>](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Installation.html)
* [<span data-ttu-id="2a36b-231">MRTK - 설명서 홈(GitHub)</span><span class="sxs-lookup"><span data-stu-id="2a36b-231">MRTK - Documentation home (GitHub)</span></span>](https://microsoft.github.io/MixedRealityToolkit-Unity/README.html)
* [<span data-ttu-id="2a36b-232">HoloToolkit/MRTK에서 MRTK 버전 2로 포팅(GitHub)</span><span class="sxs-lookup"><span data-stu-id="2a36b-232">Porting from HoloToolkit/MRTK to MRTK version 2 (GitHub)</span></span>](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/HTKToMRTKPortingGuide.html)
* [<span data-ttu-id="2a36b-233">Unity 권장 설정</span><span class="sxs-lookup"><span data-stu-id="2a36b-233">Recommended settings for Unity</span></span>](../unity/recommended-settings-for-unity.md)
* [<span data-ttu-id="2a36b-234">혼합 현실의 성능 이해</span><span class="sxs-lookup"><span data-stu-id="2a36b-234">Understanding performance for Mixed Reality</span></span>](../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md)

