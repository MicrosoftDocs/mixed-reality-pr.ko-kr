---
title: 홀로그램 안정성
description: HoloLens는 홀로그램을 자동으로 안정화하지만 개발자가 홀로그램 안정성을 개선하기 위해 취할 수 있는 단계가 있습니다.
author: thetuvix
ms.author: alexturn
ms.date: 07/08/2020
ms.topic: article
keywords: 홀로그램, 안정성, hololens, 혼합 현실 헤드셋, windows mixed reality 헤드셋, 가상 현실 헤드셋, 프레임 속도, 렌더링, 다시 프로젝션, 색 구분
appliesto:
- HoloLens
ms.openlocfilehash: a4a22221d3238bb7dfed711e6ee1f11edc70238e
ms.sourcegitcommit: 12ea3fb2df4664c5efd07dcbb9040c2ff173afb6
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/29/2021
ms.locfileid: "113042294"
---
# <a name="hologram-stability"></a><span data-ttu-id="bba6e-104">홀로그램 안정성</span><span class="sxs-lookup"><span data-stu-id="bba6e-104">Hologram stability</span></span>

<span data-ttu-id="bba6e-105">안정적인 홀로그램을 달성하기 위해 HoloLens에는 기본 제공 이미지 안정화 파이프라인이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-105">To achieve stable holograms, HoloLens has a built-in image stabilization pipeline.</span></span> <span data-ttu-id="bba6e-106">안정화 파이프라인은 백그라운드에서 자동으로 작동하므로 활성화하기 위해 추가 단계를 수행할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-106">The stabilization pipeline works automatically in the background, so you don't need to take any extra steps to enable it.</span></span> <span data-ttu-id="bba6e-107">그러나 홀로그램 안정성을 개선하고 안정성을 줄이는 시나리오를 방지하는 기술을 연습해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-107">However, you should exercise techniques that improve hologram stability and avoid scenarios that reduce stability.</span></span>

## <a name="hologram-quality-terminology"></a><span data-ttu-id="bba6e-108">홀로그램 품질 용어</span><span class="sxs-lookup"><span data-stu-id="bba6e-108">Hologram quality terminology</span></span>

<span data-ttu-id="bba6e-109">홀로그램의 품질은 좋은 환경과 좋은 앱 개발의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-109">The quality of holograms is a result of good environment and good app development.</span></span> <span data-ttu-id="bba6e-110">HoloLens가 주변을 추적할 수 있는 환경에서 초당 60프레임으로 실행되는 앱은 홀로그램과 일치하는 좌표계가 동기화되도록 합니다. 사용자의 관점에서 볼 때 고정되어야 하는 홀로그램은 환경을 기준으로 이동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-110">Apps running at a constant 60 frames-per-second in an environment where HoloLens can track the surroundings ensures the hologram and the matching coordinate system are in sync. From a user's perspective, holograms that are meant to be stationary won't move relative to the environment.</span></span>

<span data-ttu-id="bba6e-111">다음 용어는 환경 문제, 일관되지 않거나 낮은 렌더링 속도 또는 기타 문제를 식별할 때 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-111">The following terminology can help you when you're identifying problems with the environment, inconsistent or low rendering rates, or anything else.</span></span>
* <span data-ttu-id="bba6e-112">**정확도.**</span><span class="sxs-lookup"><span data-stu-id="bba6e-112">**Accuracy.**</span></span> <span data-ttu-id="bba6e-113">홀로그램이 세계 잠금 상태이고 실제 세계에 배치되면 주변 환경에 상대적으로 배치되고 사용자 동작이나 작고 스파스한 환경 변경과 무관하게 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-113">Once the hologram is world-locked and placed in the real world, it should stay where it's placed relative to the surrounding environment and independent of user motion or small and sparse environment changes.</span></span> <span data-ttu-id="bba6e-114">홀로그램이 나중에 예기치 않은 위치에 나타나는 경우 *정확도* 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-114">If a hologram later appears in an unexpected location, it's an *accuracy* problem.</span></span> <span data-ttu-id="bba6e-115">이러한 시나리오는 두 개의 서로 다른 방이 동일하게 보이는 경우에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-115">Such scenarios can happen if two distinct rooms look identical.</span></span>
* <span data-ttu-id="bba6e-116">**지터.**</span><span class="sxs-lookup"><span data-stu-id="bba6e-116">**Jitter.**</span></span> <span data-ttu-id="bba6e-117">사용자는 환경 추적이 저하되는 경우 발생할 수 있는 홀로그램의 빈도가 높은 지터를 관찰합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-117">Users observe jitter as high frequency shaking of a hologram, which can happen when tracking of the environment degrades.</span></span> <span data-ttu-id="bba6e-118">사용자의 경우 솔루션에서 [센서 튜닝을 실행합니다.](/hololens/hololens-updates)</span><span class="sxs-lookup"><span data-stu-id="bba6e-118">For users, the solution is running [sensor tuning](/hololens/hololens-updates).</span></span>
* <span data-ttu-id="bba6e-119">**Judder.**</span><span class="sxs-lookup"><span data-stu-id="bba6e-119">**Judder.**</span></span> <span data-ttu-id="bba6e-120">렌더링 빈도가 낮을 경우 홀로그램의 동작이 균일하지 않고 이중 이미지가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-120">Low rendering frequencies result in uneven motion and double images of holograms.</span></span> <span data-ttu-id="bba6e-121">Judder는 동작이 있는 홀로그램에서 특히 눈에 띄습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-121">Judder is especially noticeable in holograms with motion.</span></span> <span data-ttu-id="bba6e-122">개발자는 [상수 60 FPS 를](hologram-stability.md#frame-rate)유지 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-122">Developers need to maintain a [constant 60 FPS](hologram-stability.md#frame-rate).</span></span>
* <span data-ttu-id="bba6e-123">**드리프트.**</span><span class="sxs-lookup"><span data-stu-id="bba6e-123">**Drift.**</span></span> <span data-ttu-id="bba6e-124">홀로그램이 원래 배치된 위치에서 벗어나는 것처럼 보이면 사용자에게 드리프트가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-124">Users see drift as a hologram appears to move away from where it was originally placed.</span></span> <span data-ttu-id="bba6e-125">드리프트는 특히 환경의 매핑되지 않은 부분에 [홀로그램을 공간 앵커에서](../../design/spatial-anchors.md)멀리 떨어진 곳에 배치할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-125">Drift happens when you place holograms far away from [spatial anchors](../../design/spatial-anchors.md), particularly in unmapped parts of the environment.</span></span> <span data-ttu-id="bba6e-126">공간 앵커에 가까운 홀로그램을 만들면 드리프트 가능성이 낮아집니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-126">Creating holograms close to spatial anchors lowers the likelihood of drift.</span></span>
* <span data-ttu-id="bba6e-127">**점프.**</span><span class="sxs-lookup"><span data-stu-id="bba6e-127">**Jumpiness.**</span></span> <span data-ttu-id="bba6e-128">홀로그램이 때때로 해당 위치에서 "팝" 또는 "점프"하는 경우</span><span class="sxs-lookup"><span data-stu-id="bba6e-128">When a hologram "pops" or "jumps" away from its location occasionally.</span></span> <span data-ttu-id="bba6e-129">추적이 환경에 대한 업데이트된 이해와 일치하도록 홀로그램을 조정하면 점프가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-129">Jumpiness can occur as tracking adjusts holograms to match updated understanding of your environment.</span></span>
* <span data-ttu-id="bba6e-130">**수영.**</span><span class="sxs-lookup"><span data-stu-id="bba6e-130">**Swim.**</span></span> <span data-ttu-id="bba6e-131">홀로그램이 사용자의 머리 동작에 따라 움직이는 것처럼 보일 때</span><span class="sxs-lookup"><span data-stu-id="bba6e-131">When a hologram appears to sway corresponding to the motion of the user's head.</span></span> <span data-ttu-id="bba6e-132">스윔은 애플리케이션이 [다시 프로젝션](hologram-stability.md#reprojection)을 완전히 구현하지 않은 경우와 HoloLens가 현재 사용자에 대해 [보정되지](/hololens/hololens-calibration) 않은 경우에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-132">Swim occurs when the application hasn't fully implemented [reprojection](hologram-stability.md#reprojection), and if the HoloLens isn't [calibrated](/hololens/hololens-calibration) for the current user.</span></span> <span data-ttu-id="bba6e-133">사용자는 [보정](/hololens/hololens-calibration) 애플리케이션을 다시 실행하여 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-133">The user can rerun the [calibration](/hololens/hololens-calibration) application to fix the issue.</span></span> <span data-ttu-id="bba6e-134">개발자는 안정화 평면을 업데이트하여 안정성을 더욱 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-134">Developers can update the stabilization plane to further enhance stability.</span></span>
* <span data-ttu-id="bba6e-135">**색 구분.**</span><span class="sxs-lookup"><span data-stu-id="bba6e-135">**Color separation.**</span></span> <span data-ttu-id="bba6e-136">HoloLens의 디스플레이는 60Hz(개별 색 필드는 240Hz로 표시)에서 빨간색-녹색-파란색-녹색의 플래시 색 채널인 색 순차 디스플레이입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-136">The displays in HoloLens are color sequential displays, which flash color channels of red-green-blue-green at 60 Hz (individual color fields are shown at 240 Hz).</span></span> <span data-ttu-id="bba6e-137">사용자가 눈과 함께 움직이는 홀로그램을 추적할 때마다 홀로그램의 선행 및 후행 가장자리가 구성 색으로 구분되어 색이 비추는 효과가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-137">Whenever a user tracks a moving hologram with their eyes, that hologram's leading and trailing edges separate in their constituent colors, producing a rainbow effect.</span></span> <span data-ttu-id="bba6e-138">분리 정도는 홀로그램의 속도에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-138">The degree of separation is dependent upon the speed of the hologram.</span></span> <span data-ttu-id="bba6e-139">드문 경우지만 고정 홀로그램을 보는 동안 헤드를 빠르게 이동하면 *[색 구분이라고](hologram-stability.md#color-separation)* 하는 효과도 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-139">In some rarer cases, moving ones head rapidly while looking at a stationary hologram can also result in a rainbow effect, which is called *[color separation](hologram-stability.md#color-separation)*.</span></span>

## <a name="frame-rate"></a><span data-ttu-id="bba6e-140">프레임 속도</span><span class="sxs-lookup"><span data-stu-id="bba6e-140">Frame rate</span></span>

<span data-ttu-id="bba6e-141">프레임 속도는 홀로그램 안정성의 첫 번째 핵심 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-141">Frame rate is the first pillar of hologram stability.</span></span> <span data-ttu-id="bba6e-142">홀로그램이 세계에서 안정적으로 나타나려면 사용자에게 표시되는 각 이미지에 올바른 지점에 홀로그램이 그려져 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-142">For holograms to appear stable in the world, each image presented to the user must have the holograms drawn in the correct spot.</span></span> <span data-ttu-id="bba6e-143">HoloLens의 디스플레이는 1초에 240번 새로 고쳐지고 새로 렌더링된 각 이미지에 대해 4개의 개별 색 필드를 표시하여 60FPS(초당 프레임)의 사용자 환경을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-143">The displays on HoloLens refresh 240 times a second, showing four separate color fields for each newly rendered image, resulting in a user experience of 60 FPS (frames per second).</span></span> <span data-ttu-id="bba6e-144">가능한 최상의 환경을 제공하려면 애플리케이션 개발자가 60개의 FPS를 유지 관리해야 하며, 이는 16밀리초마다 운영 체제에 새 이미지를 일관되게 제공하는 것으로 변환됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-144">To provide the best experience possible, application developers must maintain 60 FPS, which translates to consistently providing a new image to the operating system every 16 milliseconds.</span></span>

<span data-ttu-id="bba6e-145">**60 FPS** 실제 세계에 있는 것처럼 보이도록 홀로그램을 그리려면 HoloLens는 사용자의 위치에서 이미지를 렌더링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-145">**60 FPS** To draw holograms to look like they're sitting in the real world, HoloLens needs to render images from the user's position.</span></span> <span data-ttu-id="bba6e-146">이미지 렌더링에는 시간이 걸리므로 HoloLens는 이미지가 디스플레이에 표시될 때 사용자의 머리 위치를 예측합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-146">Since image rendering takes time, HoloLens predicts where a user's head will be when the images are shown in the displays.</span></span> <span data-ttu-id="bba6e-147">그러나 이 예측 알고리즘은 근사값입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-147">However, this prediction algorithm is an approximation.</span></span> <span data-ttu-id="bba6e-148">HoloLens에는 예측된 헤드 위치와 실제 머리 위치 간의 불일치를 고려하여 렌더링된 이미지를 조정하는 하드웨어가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-148">HoloLens has hardware that adjusts the rendered image to account for the discrepancy between the predicted head position and the actual head position.</span></span> <span data-ttu-id="bba6e-149">조정을 통해 사용자가 보는 이미지가 올바른 위치에서 렌더링된 것처럼 표시되고 홀로그램이 안정적이라고 느낄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-149">The adjustment makes the image the user sees appear as if it's rendered from the correct location, and holograms feel stable.</span></span> <span data-ttu-id="bba6e-150">이미지 업데이트는 작은 변경 내용에서 가장 잘 작동하며, 렌더링된 이미지에서 동작 시차와 같은 특정 사항을 완전히 수정할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-150">The image updates work best with small changes, and it can't completely fix certain things in the rendered image like motion-parallax.</span></span>

<span data-ttu-id="bba6e-151">60 FPS에서 렌더링하면 안정적인 홀로그램을 만드는 데 도움이 되는 세 가지 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-151">By rendering at 60 FPS, you're doing three things to help make stable holograms:</span></span>
1. <span data-ttu-id="bba6e-152">이미지를 렌더링하는 것과 사용자가 볼 수 있는 이미지 사이의 전체 대기 시간을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-152">Minimizing the overall latency between rendering an image and that image being seen by the user.</span></span> <span data-ttu-id="bba6e-153">게임 및 렌더링 스레드가 잠금 단계에서 실행되는 엔진에서 30FPS에서 실행하면 33.3ms의 대기 시간이 더 늘어나게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-153">In an engine with a game and a render thread running in lockstep, running at 30FPS can add 33.3 ms of extra latency.</span></span> <span data-ttu-id="bba6e-154">대기 시간을 줄이면 예측 오류가 감소하고 홀로그램 안정성이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-154">Reducing latency decreases prediction error and increases hologram stability.</span></span>
2. <span data-ttu-id="bba6e-155">사용자의 눈에 도달하는 모든 이미지가 일관된 대기 시간을 갖도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-155">Making it so every image reaching the user's eyes have a consistent amount of latency.</span></span> <span data-ttu-id="bba6e-156">30fps로 렌더링하는 경우 60FPS로 이미지가 계속 표시됩니다. 즉, 동일한 이미지가 한 행에 두 번 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-156">If you render at 30 fps, the display still displays images at 60 FPS, meaning the same image will be displayed twice in a row.</span></span> <span data-ttu-id="bba6e-157">두 번째 프레임은 첫 번째 프레임보다 16.6ms 더 많은 대기 시간을 가지며 더 뚜렷한 양의 오류를 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-157">The second frame will have 16.6-ms more latency than the first frame and will have to correct a more pronounced amount of error.</span></span> <span data-ttu-id="bba6e-158">이러한 오류 크기 불일치로 인해 원치 않는 60Hz 유도가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-158">This inconsistency in error magnitude can cause unwanted 60 Hz judder.</span></span>
3. <span data-ttu-id="bba6e-159">고르지 않은 모션과 이중 이미지를 특징으로 하는 심한 진동(judder)의 모양을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-159">Reducing the appearance of judder, which is characterized by uneven motion and double images.</span></span> <span data-ttu-id="bba6e-160">더 빠른 홀로그램 모션과 낮은 렌더링 속도는 더 뚜렷한 심한 진동과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-160">Faster hologram motion and lower render rates are associated with more pronounced judder.</span></span> <span data-ttu-id="bba6e-161">항상 60 FPS를 유지 관리하기 위해 노력하면 지정된 이동 홀로그램에 대한 유도를 방지하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-161">Striving to maintain 60 FPS at all times will help avoid judder for a given moving hologram.</span></span>

<span data-ttu-id="bba6e-162">**프레임 속도 일관성** 프레임 속도 일관성은 초당 높은 프레임 수만큼 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-162">**Frame-rate consistency** Frame rate consistency is as important as a high frames-per-second.</span></span> <span data-ttu-id="bba6e-163">경우에 따라 삭제된 프레임은 콘텐츠가 풍부한 애플리케이션에서 피할 수 없으며, HoloLens는 간헐적인 결함으로부터 복구하기 위해 몇 가지 정교한 알고리즘을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-163">Occasionally dropped frames are inevitable for any content-rich application, and the HoloLens implements some sophisticated algorithms to recover from occasional glitches.</span></span> <span data-ttu-id="bba6e-164">그러나 지속적으로 변동하는 프레임 속도는 더 낮은 프레임 속도로 일관되게 실행하는 것보다 사용자에게 훨씬 더 눈에 띄습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-164">However, a constantly fluctuating framerate is a lot more noticeable to a user than running consistently at lower frame rates.</span></span> <span data-ttu-id="bba6e-165">예를 들어 5개 프레임(이 5개 프레임 동안 60FPS)에 대해 원활하게 렌더링한 다음, 다음 10개 프레임(이 10개 프레임 동안 30FPS)에 대해 다른 모든 프레임을 삭제하는 애플리케이션은 30FPS에서 일관되게 렌더링되는 애플리케이션보다 더 불안정하게 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-165">For example, an application that renders smoothly for five frames (60 FPS for the duration of these five frames) and then drops every other frame for the next 10 frames (30 FPS for the duration of these 10 frames) will appear more unstable than an application that consistently renders at 30 FPS.</span></span>

<span data-ttu-id="bba6e-166">관련 참고 사항에서 운영 체제는 [혼합 현실 캡처가](/hololens/holographic-photos-and-videos) 실행 중일 때 애플리케이션을 30 FPS로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-166">On a related note, the operating system throttles down applications to 30 FPS when [mixed reality capture](/hololens/holographic-photos-and-videos) is running.</span></span>

<span data-ttu-id="bba6e-167">**성능 분석** 다음과 같이 애플리케이션 프레임 속도를 벤치마크하는 데 사용할 수 있는 다양한 종류의 도구가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-167">**Performance analysis** There are different kinds of tools that can be used to benchmark your application frame rate, such as:</span></span>
* <span data-ttu-id="bba6e-168">GPUView</span><span class="sxs-lookup"><span data-stu-id="bba6e-168">GPUView</span></span>
* <span data-ttu-id="bba6e-169">Visual Studio 그래픽 디버거</span><span class="sxs-lookup"><span data-stu-id="bba6e-169">Visual Studio Graphics Debugger</span></span>
* <span data-ttu-id="bba6e-170">Unity와 같은 3D 엔진에 기본 제공되는 프로파일러</span><span class="sxs-lookup"><span data-stu-id="bba6e-170">Profilers built into 3D engines such as Unity</span></span>

## <a name="hologram-render-distances"></a><span data-ttu-id="bba6e-171">홀로그램 렌더링 거리</span><span class="sxs-lookup"><span data-stu-id="bba6e-171">Hologram render distances</span></span>

>[!VIDEO https://www.youtube.com/embed/-606oZKLa_s]

<span data-ttu-id="bba6e-172">인간 시각적 개체 시스템은 개체를 고정하고 중시할 때 여러 거리 종속 신호를 통합합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-172">The human visual system integrates multiple distance-dependent signals when it fixates and focuses on an object.</span></span>
* <span data-ttu-id="bba6e-173">[편의성](https://en.wikipedia.org/wiki/Accommodation_%28eye%29) - 개별 시선의 포커스입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-173">[Accommodation](https://en.wikipedia.org/wiki/Accommodation_%28eye%29) - The focus of an individual eye.</span></span>
* <span data-ttu-id="bba6e-174">[수렴](https://en.wikipedia.org/wiki/Convergence_(eye)) - 두 개의 눈은 개체의 가운데에 오도록 안쪽 또는 바깥쪽으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-174">[Convergence](https://en.wikipedia.org/wiki/Convergence_(eye)) - Two eyes moving inward or outward to center on an object.</span></span>
* <span data-ttu-id="bba6e-175">[이항 비전](https://en.wikipedia.org/wiki/Stereopsis) - 고정 지점에서 멀리 떨어진 개체의 거리에 종속된 왼쪽 및 오른쪽 눈 이미지 간의 차이입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-175">[Binocular vision](https://en.wikipedia.org/wiki/Stereopsis) - Disparities between the left- and right-eye images that are dependent on an object's distance away from your fixation point.</span></span>
* <span data-ttu-id="bba6e-176">음영, 상대 각도 크기 및 기타 단색(단안) 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-176">Shading, relative angular size, and other monocular (single eye) cues.</span></span>

<span data-ttu-id="bba6e-177">수렴 및 수용성은 서로 다른 거리에 있는 개체를 인식하기 위해 시선이 변하는 방식과 관련된 지속성 신호이기 때문에 고유합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-177">Convergence and accommodation are unique because their extra-retinal cues related to how the eyes change to perceive objects at different distances.</span></span> <span data-ttu-id="bba6e-178">자연스러운 보기에서는 수렴 및 수용이 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-178">In natural viewing, convergence and accommodation are linked.</span></span> <span data-ttu-id="bba6e-179">눈에서 가까운 것(예: 코)을 볼 때 눈은 교차하고 가까운 지점에 맞습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-179">When the eyes view something near (for example, your nose), the eyes cross and accommodate to a near point.</span></span> <span data-ttu-id="bba6e-180">눈에서 무한대로 무언가를 볼 때 눈은 병렬이 되고 눈은 무한대로 수용됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-180">When the eyes view something at infinity, the eyes become parallel and the eye accommodates to infinity.</span></span> 

<span data-ttu-id="bba6e-181">HoloLens 디스플레이가 사용자로부터 약 2.0m 떨어진 광학 거리에 고정되어 있기 때문에 HoloLens를 쓴 사용자는 항상 2.0m를 수용하여 명확한 이미지를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-181">Users wearing HoloLens will always accommodate to 2.0 m to maintain a clear image because the HoloLens displays are fixed at an optical distance approximately 2.0 m away from the user.</span></span> <span data-ttu-id="bba6e-182">앱 개발자는 콘텐츠와 홀로그램을 다양한 깊이에 배치하여 사용자의 시선이 수렴되는 위치를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-182">App developers control where users' eyes converge by placing content and holograms at various depths.</span></span> <span data-ttu-id="bba6e-183">사용자가 서로 다른 거리를 수용하고 수렴하면 두 큐 간의 자연스러운 연결이 끊어지며, 특히 충돌 크기가 큰 경우 시각적으로 불편하거나 불편할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-183">When users accommodate and converge to different distances, the natural link between the two cues is broken, which can lead to visual discomfort or fatigue, especially when the magnitude of the conflict is large.</span></span> 

<span data-ttu-id="bba6e-184">수렴된 콘텐츠를 가능한 한 2.0m에 가깝게 유지하여(즉, 깊이가 많은 장면에서 가능한 경우 2.0m 가까이의 관심 영역) 수렴-조정 충돌에서의 불편을 방지하거나 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-184">Discomfort from the vergence-accommodation conflict can be avoided or minimized by keeping converged content as close to 2.0 m as possible (that is, in a scene with lots of depth place the areas of interest near 2.0 m, when possible).</span></span> <span data-ttu-id="bba6e-185">콘텐츠를 2.0m 가까이 배치할 수 없는 경우 사용자가 서로 다른 거리를 앞뒤로 응시할 때 수평적-충돌의 불편이 가장 커야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-185">When content can't be placed near 2.0 m, discomfort from the vergence-accommodation conflict is greatest when user’s gaze back and forth between different distances.</span></span> <span data-ttu-id="bba6e-186">다시 말해, 자신과 50cm 떨어져 있고 시간이 지남에 따라 자신과 멀어지는 홀로그램을 보는 것보다 50cm 떨어져 있는 고정 홀로그램을 보는 것이 훨씬 더 편안합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-186">In other words, it's much more comfortable to look at a stationary hologram that stays 50 cm away than to look at a hologram 50 cm away that moves toward and away from you over time.</span></span>

<span data-ttu-id="bba6e-187">두 디스플레이가 이 거리에 완전히 겹치도록 설계되어 있으므로 2.0m에 콘텐츠를 배치하는 것도 유리합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-187">Placing content at 2.0 m is also advantageous because the two displays are designed to fully overlap at this distance.</span></span> <span data-ttu-id="bba6e-188">이 평면을 벗어난 이미지의 경우 홀로그램 프레임의 측면에서 이동하면서 다른 화면에 계속 표시되는 동안 한 디스플레이에서 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-188">For images placed off this plane, as they move off the side of the holographic frame they'll appear from one display while still being visible on the other.</span></span> <span data-ttu-id="bba6e-189">이 쌍안경색은 홀로그램의 깊이 인식에 지장을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-189">This binocular rivalry can be disruptive to the depth perception of the hologram.</span></span>

<span data-ttu-id="bba6e-190">**사용자로부터 홀로그램을 배치하는 데 가장 적합한 거리**</span><span class="sxs-lookup"><span data-stu-id="bba6e-190">**Optimal distance for placing holograms from the user**</span></span>

![사용자로부터 홀로그램을 배치하는 데 가장 적합한 거리](images/distanceguiderendering-750px.png)

<span data-ttu-id="bba6e-192">**클립 평면** 최대한의 편의를 위해 85cm에서 렌더링 거리를 클리핑하고 1m부터 콘텐츠 페이드 아웃을 수행하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-192">**Clip Planes** For maximum comfort, we recommend clipping render distance at 85 cm with fade out of content starting at 1 m.</span></span> <span data-ttu-id="bba6e-193">홀로그램과 사용자가 모두 고정된 애플리케이션에서 홀로그램은 50cm에 가까울 만큼 편안하게 볼 수 있습니다. 이러한 경우 애플리케이션은 클립 평면을 30cm 이하로 배치하고 페이드 아웃은 클립 평면에서 10cm 이상 떨어진 곳에서 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-193">In applications where holograms and users are both stationary, holograms can be viewed comfortably as near as 50 cm. In those cases, applications should place a clip plane no closer than 30 cm and fade out should start at least 10 cm away from the clip plane.</span></span> <span data-ttu-id="bba6e-194">콘텐츠가 85cm보다 가까울 때마다 사용자가 홀로그램에서 더 가깝거나 더 멀리 이동하지 않거나 홀로그램이 사용자와 더 가깝거나 더 멀리 이동하지 않도록 하는 것이 중요합니다. 이러한 상황으로 인해 10진수-10진수 충돌이 발생할 가능성이 높기 때문일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-194">Whenever content is closer than 85 cm, it's important to ensure that users don't frequently move closer or farther from holograms or that holograms don't frequently move closer to or farther from the user as these situations are most likely to cause discomfort from the vergence-accommodation conflict.</span></span> <span data-ttu-id="bba6e-195">콘텐츠는 사용자로부터 85cm보다 가까운 상호 작용의 필요성을 최소화하도록 설계되어야 하지만, 콘텐츠를 85cm보다 가깝게 렌더링해야 하는 경우 개발자에게 좋은 규칙은 사용자 및/또는 홀로그램이 25%를 초과하여 깊이 이동하지 않는 시나리오를 설계하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-195">Content should be designed to minimize the need for interaction closer than 85 cm from the user, but when content must be rendered closer than 85 cm, a good rule of thumb for developers is to design scenarios where users and/or holograms don't move in depth more than 25% of the time.</span></span>

<span data-ttu-id="bba6e-196">**모범 사례** 홀로그램을 2m에 배치할 수 없고 수렴과 수용 사이의 충돌을 피할 수 없는 경우 홀로그램 배치를 위한 최적의 영역은 1.25m에서 5m 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-196">**Best practices** When holograms can't be placed at 2 m and conflicts between convergence and accommodation can't be avoided, the optimal zone for hologram placement is between 1.25 m and 5 m.</span></span> <span data-ttu-id="bba6e-197">모든 경우에 디자이너는 사용자가 1m 이상 떨어진 곳에서 상호 작용하도록 콘텐츠를 구성해야 합니다(예: 콘텐츠 크기 및 기본 배치 매개 변수 조정).</span><span class="sxs-lookup"><span data-stu-id="bba6e-197">In every case, designers should structure content to encourage users to interact 1+ m away (for example, adjust content size and default placement parameters).</span></span>

## <a name="reprojection"></a><span data-ttu-id="bba6e-198">다시 프로젝션</span><span class="sxs-lookup"><span data-stu-id="bba6e-198">Reprojection</span></span>
<span data-ttu-id="bba6e-199">HoloLens에는 재프로젝션이라고 하는 정교한 하드웨어 지원 홀로그램 안정화 기술이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-199">HoloLens has a sophisticated hardware-assisted holographic stabilization technique known as reprojection.</span></span> <span data-ttu-id="bba6e-200">다시 프로젝션은 장면에 애니메이션이 추가되고 사용자가 헤드를 움직이면 보기 지점(CameraPose)의 동작 및 변경을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-200">Reprojection takes into account motion and change of the point of view (CameraPose) as the scene animates and the user moves their head.</span></span>  <span data-ttu-id="bba6e-201">애플리케이션은 다시 프로젝션을 가장 잘 사용하려면 특정 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-201">Applications need to take specific actions to best use reprojection.</span></span>


<span data-ttu-id="bba6e-202">네 가지 주요 유형의 다시 프로젝션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-202">There are four main types of reprojection</span></span>
* <span data-ttu-id="bba6e-203">**깊이 다시 프로젝션:**  애플리케이션에서 최소한의 노력으로 최상의 결과를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-203">**Depth Reprojection:**  Produces the best results with the least amount of effort from the application.</span></span>  <span data-ttu-id="bba6e-204">렌더링된 장면의 모든 부분은 사용자와의 거리를 기준으로 독립적으로 안정화됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-204">All parts of the rendered scene are independently stabilized based on their distance from the user.</span></span>  <span data-ttu-id="bba6e-205">일부 렌더링 아티팩트에서는 심층적인 변경 내용이 있는 경우 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-205">Some rendering artifacts may be visible where there are sharp changes in depth.</span></span>  <span data-ttu-id="bba6e-206">이 옵션은 HoloLens 2 및 몰입형 헤드셋에서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-206">This option is only available on HoloLens 2 and Immersive Headsets.</span></span>
* <span data-ttu-id="bba6e-207">**평면 다시 프로젝션:**  애플리케이션에서 안정화를 정확하게 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-207">**Planar Reprojection:**  Allows the application precise control over stabilization.</span></span>  <span data-ttu-id="bba6e-208">평면은 애플리케이션에 의해 설정되며 해당 평면의 모든 것이 장면의 가장 안정적인 부분이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-208">A plane is set by the application and everything on that plane will be the most stable part of the scene.</span></span>  <span data-ttu-id="bba6e-209">홀로그램이 평면에서 멀리 떨어져 있을수록 안정성이 떨어지게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-209">The further a hologram is away from the plane, the less stable it will be.</span></span>  <span data-ttu-id="bba6e-210">이 옵션은 모든 Windows MR 플랫폼에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-210">This option is available on all Windows MR platforms.</span></span>
* <span data-ttu-id="bba6e-211">**자동 평면 다시 프로젝션:**  시스템은 깊이 버퍼의 정보를 사용하여 안정화 평면을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-211">**Automatic Planar Reprojection:**  The system sets a stabilization plane using information in the depth buffer.</span></span>  <span data-ttu-id="bba6e-212">이 옵션은 HoloLens 1세대 및 HoloLens 2 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-212">This option is available on HoloLens generation 1 and HoloLens 2.</span></span>
* <span data-ttu-id="bba6e-213">**없음:** 애플리케이션에서 아무 것도 수행하지 않는 경우 평면 다시 프로젝션은 사용자의 머리 응시 방향으로 2미터 고정된 안정화 평면과 함께 사용되며, 일반적으로 표준이 낮은 결과를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-213">**None:** If the application does nothing, Planar Reprojection is used with the stabilization plane fixed at 2 meters in the direction of the user's head gaze, usually producing substandard results.</span></span>

<span data-ttu-id="bba6e-214">애플리케이션은 다양한 유형의 다시 프로젝션을 사용하도록 설정하기 위해 특정 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-214">Applications need to take specific actions to enable the different types of reprojection</span></span>
* <span data-ttu-id="bba6e-215">**깊이 다시 프로젝션:** 애플리케이션은 렌더링된 모든 프레임에 대해 깊이 버퍼를 시스템에 제출합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-215">**Depth Reprojection:** The application submits their depth buffer to the system for every rendered frame.</span></span>  <span data-ttu-id="bba6e-216">Unity에서 깊이 다시 프로젝션은 **XR 플러그 인 관리** **아래의 Windows Mixed Reality 설정** 창에서 공유 깊이 **버퍼** 옵션을 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-216">On Unity, Depth Reprojection is done with the **Shared Depth Buffer** option in the **Windows Mixed Reality Settings** pane under **XR Plugin Management**.</span></span>  <span data-ttu-id="bba6e-217">DirectX 앱은 CommitDirect3D11DepthBuffer를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-217">DirectX apps call CommitDirect3D11DepthBuffer.</span></span>  <span data-ttu-id="bba6e-218">애플리케이션은 SetFocusPoint를 호출하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-218">The application shouldn't call SetFocusPoint.</span></span>
* <span data-ttu-id="bba6e-219">**평면 다시 프로젝션:** 모든 프레임에서 애플리케이션은 안정화할 평면의 위치를 시스템에 알려줍니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-219">**Planar Reprojection:** On every frame, applications tell the system the location of a plane to stabilize.</span></span>  <span data-ttu-id="bba6e-220">Unity 애플리케이션은 SetFocusPointForFrame을 호출하며 **공유 깊이 버퍼를** 사용하지 않도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-220">Unity applications call SetFocusPointForFrame and should have **Shared Depth Buffer** disabled.</span></span>  <span data-ttu-id="bba6e-221">DirectX 앱은 SetFocusPoint를 호출하며 CommitDirect3D11DepthBuffer를 호출하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-221">DirectX apps call SetFocusPoint and shouldn't call CommitDirect3D11DepthBuffer.</span></span>
* <span data-ttu-id="bba6e-222">**자동 평면 다시 프로젝션:** 사용하도록 설정하려면 애플리케이션에서 깊이 다시 프로젝션과 마찬가지로 깊이 버퍼를 시스템에 제출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-222">**Automatic Planar Reprojection:** To enable, the application needs to submit their depth buffer to the system as they would for Depth Reprojection.</span></span> <span data-ttu-id="bba6e-223">MRTK(Mixed Reality Toolkit)를 사용하는 앱은 AutoPlanar Reprojection을 사용하도록 [카메라 설정 공급자를](/windows/mixed-reality/mrtk-unity/features/camera-system/windows-mixed-reality-camera-settings#hololens-2-reprojection-method) 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-223">Apps using the Mixed Reality Toolkit (MRTK) can configure the [camera settings provider](/windows/mixed-reality/mrtk-unity/features/camera-system/windows-mixed-reality-camera-settings#hololens-2-reprojection-method) to use AutoPlanar Reprojection.</span></span> <span data-ttu-id="bba6e-224">네이티브 앱은 `DepthReprojectionMode` [HolographicCameraRenderingParameters의](/uwp/api/windows.graphics.holographic.holographiccamerarenderingparameters) 를 각 프레임으로 설정해야 `AutoPlanar` 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-224">Native apps should set the `DepthReprojectionMode` in the [HolographicCameraRenderingParameters](/uwp/api/windows.graphics.holographic.holographiccamerarenderingparameters) to `AutoPlanar` each frame.</span></span> <span data-ttu-id="bba6e-225">HoloLens 1세대의 경우 애플리케이션에서 SetFocusPoint를 호출하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-225">For HoloLens generation 1, the application should not call SetFocusPoint.</span></span>

### <a name="choosing-reprojection-technique"></a><span data-ttu-id="bba6e-226">다시 프로젝션 기술 선택</span><span class="sxs-lookup"><span data-stu-id="bba6e-226">Choosing Reprojection Technique</span></span>

<span data-ttu-id="bba6e-227">안정화 유형</span><span class="sxs-lookup"><span data-stu-id="bba6e-227">Stabilization Type</span></span> |    <span data-ttu-id="bba6e-228">몰입형 헤드셋</span><span class="sxs-lookup"><span data-stu-id="bba6e-228">Immersive Headsets</span></span> |    <span data-ttu-id="bba6e-229">HoloLens 1세대</span><span class="sxs-lookup"><span data-stu-id="bba6e-229">HoloLens generation 1</span></span> | <span data-ttu-id="bba6e-230">HoloLens 2</span><span class="sxs-lookup"><span data-stu-id="bba6e-230">HoloLens 2</span></span>
--- | --- | --- | ---
<span data-ttu-id="bba6e-231">깊이 다시 프로젝션</span><span class="sxs-lookup"><span data-stu-id="bba6e-231">Depth Reprojection</span></span> |    <span data-ttu-id="bba6e-232">권장</span><span class="sxs-lookup"><span data-stu-id="bba6e-232">Recommended</span></span> |   <span data-ttu-id="bba6e-233">해당 없음</span><span class="sxs-lookup"><span data-stu-id="bba6e-233">N/A</span></span> |   <span data-ttu-id="bba6e-234">권장</span><span class="sxs-lookup"><span data-stu-id="bba6e-234">Recommended</span></span><br/><br/><span data-ttu-id="bba6e-235">Unity 애플리케이션은 Unity 2018.4.12 이상, Unity 2019.3 이상 또는 Unity 2020.3+를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-235">Unity applications must use Unity 2018.4.12+, Unity 2019.3+ or Unity 2020.3+.</span></span> <span data-ttu-id="bba6e-236">그렇지 않으면 자동 평면 다시 프로젝션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-236">Otherwise use Automatic Planar Reprojection.</span></span>
<span data-ttu-id="bba6e-237">자동 평면 다시 프로젝션</span><span class="sxs-lookup"><span data-stu-id="bba6e-237">Automatic Planar Reprojection</span></span> | <span data-ttu-id="bba6e-238">해당 없음</span><span class="sxs-lookup"><span data-stu-id="bba6e-238">N/A</span></span> |   <span data-ttu-id="bba6e-239">권장되는 기본값</span><span class="sxs-lookup"><span data-stu-id="bba6e-239">Recommended default</span></span> |   <span data-ttu-id="bba6e-240">깊이 다시 프로젝션이 최상의 결과를 제공하지 않는 경우 권장</span><span class="sxs-lookup"><span data-stu-id="bba6e-240">Recommended if Depth Reprojection isn't giving the best results</span></span><br/><br/><span data-ttu-id="bba6e-241">Unity 애플리케이션은 Unity 2018.4.12 이상, Unity 2019.3 이상 또는 Unity 2020.3+를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-241">Unity applications are recommended to use Unity 2018.4.12+, Unity 2019.3+ or Unity 2020.3+.</span></span>  <span data-ttu-id="bba6e-242">이전 Unity 버전은 약간 저하된 다시 프로젝션 결과에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-242">Previous Unity versions will work with slightly degraded reprojection results.</span></span>
<span data-ttu-id="bba6e-243">평면 다시 프로젝션</span><span class="sxs-lookup"><span data-stu-id="bba6e-243">Planar Reprojection</span></span> |   <span data-ttu-id="bba6e-244">권장하지 않음</span><span class="sxs-lookup"><span data-stu-id="bba6e-244">Not Recommended</span></span> |   <span data-ttu-id="bba6e-245">자동 평면이 최상의 결과를 제공하지 않는 경우 권장</span><span class="sxs-lookup"><span data-stu-id="bba6e-245">Recommended if Automatic Planar isn't giving the best results</span></span> | <span data-ttu-id="bba6e-246">깊이 옵션 중 어느 것도 원하는 결과를 제공하지 않으면 를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-246">Use if neither of the depth options give desired results</span></span>    

### <a name="verifying-depth-is-set-correctly"></a><span data-ttu-id="bba6e-247">깊이가 올바르게 설정되었는지 확인</span><span class="sxs-lookup"><span data-stu-id="bba6e-247">Verifying Depth is Set Correctly</span></span>
            
<span data-ttu-id="bba6e-248">다시 프로젝션 메서드가 깊이 버퍼를 사용하는 경우 깊이 버퍼의 내용이 애플리케이션의 렌더링된 장면을 나타내는지 확인하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-248">When a reprojection method uses the depth buffer, it's important to verify the contents of the depth buffer represent the application's rendered scene.</span></span>  <span data-ttu-id="bba6e-249">여러 가지 요인으로 인해 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-249">A number of factors can cause problems.</span></span> <span data-ttu-id="bba6e-250">예를 들어 사용자 인터페이스 오버레이를 렌더링하는 데 사용되는 두 번째 카메라가 있는 경우 실제 보기에서 모든 깊이 정보를 덮어쓰는 것일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-250">If there's a second camera used to render user interface overlays, for example, it's likely to overwrite all the depth information from the actual view.</span></span>  <span data-ttu-id="bba6e-251">투명 개체는 깊이를 설정하지 않는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-251">Transparent objects often don't set depth.</span></span>  <span data-ttu-id="bba6e-252">일부 텍스트 렌더링은 기본적으로 깊이를 설정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-252">Some text rendering won't set depth by default.</span></span>  <span data-ttu-id="bba6e-253">깊이가 렌더링된 홀로그램과 일치하지 않는 경우 렌더링에 표시되는 결함이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-253">There will be visible glitches in the rendering when depth doesn't match the rendered holograms.</span></span>
            
<span data-ttu-id="bba6e-254">HoloLens 2 깊이가 설정되고 설정되지 않은 위치를 표시하는 시각화 도우미가 있으며 장치 포털 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-254">HoloLens 2 has a visualizer to show where depth is and isn't being set, which can be enabled from Device Portal.</span></span>  <span data-ttu-id="bba6e-255">보기   >  **홀로그램 안정성** **탭에서 헤드셋의 깊이 시각화 표시** 확인란을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-255">On the **Views** > **Hologram Stability** tab, select the **Display depth visualization in headset** checkbox.</span></span>  <span data-ttu-id="bba6e-256">깊이가 제대로 설정된 영역은 파란색이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-256">Areas that have depth set properly will be blue.</span></span>  <span data-ttu-id="bba6e-257">깊이 집합이 없는 렌더링된 항목은 빨간색으로 표시되며 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-257">Rendered items that don't have depth set are marked in red and need to be fixed.</span></span>  

> [!NOTE]
> <span data-ttu-id="bba6e-258">깊이의 시각화는 혼합 현실 캡처 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-258">The visualization of the depth will not show up in Mixed Reality Capture.</span></span>  <span data-ttu-id="bba6e-259">디바이스를 통해서만 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-259">It is only visible through the device.</span></span>
            
<span data-ttu-id="bba6e-260">일부 GPU 보기 도구는 깊이 버퍼의 시각화를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-260">Some GPU viewing tools will allow visualization of the depth buffer.</span></span>  <span data-ttu-id="bba6e-261">애플리케이션 개발자는 이러한 도구를 사용하여 깊이가 제대로 설정되고 있는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-261">Application developers can use these tools to make sure depth is being set properly.</span></span>  <span data-ttu-id="bba6e-262">애플리케이션의 도구에 대한 설명서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="bba6e-262">Consult the documentation for the application's tools.</span></span>

### <a name="using-planar-reprojection"></a><span data-ttu-id="bba6e-263">평면 다시 프로젝션 사용</span><span class="sxs-lookup"><span data-stu-id="bba6e-263">Using Planar Reprojection</span></span>
> [!NOTE]
> <span data-ttu-id="bba6e-264">데스크톱 몰입형 헤드셋의 경우 안정화 평면 설정은 픽셀별 깊이 기반 다시 프로젝션을 사용하도록 설정하기 위해 앱의 깊이 버퍼를 시스템에 제공하는 것보다 시각적 품질이 떨어지기 때문에 일반적으로 비생산적입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-264">For desktop immersive headsets, setting a stabilization plane is usually counter-productive, as it offers less visual quality than providing your app's depth buffer to the system to enable per-pixel depth-based reprojection.</span></span> <span data-ttu-id="bba6e-265">HoloLens에서 실행하지 않는 한 일반적으로 안정화 평면을 설정하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-265">Unless running on a HoloLens, you should generally avoid setting the stabilization plane.</span></span>

![3D 개체의 안정화 평면](images/stab-plane-500px.jpg)

<span data-ttu-id="bba6e-267">디바이스는 이 평면을 자동으로 선택하려고 시도하지만 애플리케이션은 장면에서 포커스 지점을 선택하여 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-267">The device will automatically attempt to choose this plane, but the application should assist by selecting the focus point in the scene.</span></span> <span data-ttu-id="bba6e-268">HoloLens에서 실행되는 Unity 앱은 장면에 따라 가장 적합한 포커스 지점을 선택하고 [SetFocusPoint()](../unity/focus-point-in-unity.md)에 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-268">Unity apps running on a HoloLens should choose the best focus point based on your scene and pass it into [SetFocusPoint()](../unity/focus-point-in-unity.md).</span></span> <span data-ttu-id="bba6e-269">DirectX에서 포커스 지점을 설정하는 예제는 기본 회전 큐브 템플릿에 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-269">An example of setting the focus point in DirectX is included in the default spinning cube template.</span></span>

<span data-ttu-id="bba6e-270">Unity는 데스크톱 PC에 연결된 몰입형 헤드셋에서 앱을 실행할 때 픽셀당 다시 프로젝션을 사용할 수 있도록 깊이 버퍼를 Windows에 제출합니다. 그러면 앱에서 명시적으로 작업하지 않고도 훨씬 더 나은 이미지 품질을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-270">Unity will submit your depth buffer to Windows to enable per-pixel reprojection when you run your app on an immersive headset connected to a desktop PC, which provides even better image quality without explicit work by the app.</span></span> <span data-ttu-id="bba6e-271">앱이 HoloLens에서 실행 중이거나 픽셀당 다시 프로젝션이 재정의되는 경우에만 포커스 지점을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-271">You should only provide a Focus Point when your app is running on a HoloLens, or the per-pixel reprojection will be overridden.</span></span>


```cs
// SetFocusPoint informs the system about a specific point in your scene to
// prioritize for image stabilization. The focus point is set independently
// for each holographic camera.
// You should set the focus point near the content that the user is looking at.
// In this example, we put the focus point at the center of the sample hologram,
// since that is the only hologram available for the user to focus on.
// You can also set the relative velocity and facing of that content; the sample
// hologram is at a fixed point so we only need to indicate its position.
renderingParameters.SetFocusPoint(
    currentCoordinateSystem,
    spinningCubeRenderer.Position
    );
```

<span data-ttu-id="bba6e-272">포커스 지점의 배치는 주로 홀로그램이 보고 있는 내용에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-272">Placement of the focus point largely depends on what the hologram is looking at.</span></span> <span data-ttu-id="bba6e-273">앱에는 참조를 위한 응시 벡터가 있으며 앱 디자이너는 사용자가 관찰할 콘텐츠를 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-273">The app has the gaze vector for reference and the app designer knows what content they want the user to observe.</span></span>

<span data-ttu-id="bba6e-274">개발자가 홀로그램을 안정화하기 위해 수행할 수 있는 가장 중요한 일은 60FPS로 렌더링하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-274">The single most important thing a developer can do to stabilize holograms is to render at 60 FPS.</span></span> <span data-ttu-id="bba6e-275">60FPS 미만으로 떨어지면 안정화 평면 최적화에 관계없이 홀로그램 안정성이 크게 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-275">Dropping below 60 FPS will dramatically reduce hologram stability, whatever the stabilization plane optimization.</span></span>

<span data-ttu-id="bba6e-276">**모범 사례** 안정화 평면을 설정하는 범용 방법은 없으며 앱별로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-276">**Best practices** There's no universal way to set up the stabilization plane and it's app-specific.</span></span> <span data-ttu-id="bba6e-277">주요 권장 사항은 시나리오에 가장 적합한 것을 실험하고 확인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-277">Our main recommendation is to experiment and see what works best for your scenario.</span></span> <span data-ttu-id="bba6e-278">그러나 이 평면의 모든 콘텐츠가 완벽하게 안정화되므로 안정화 평면을 최대한 많은 콘텐츠와 정렬해 보세요.</span><span class="sxs-lookup"><span data-stu-id="bba6e-278">However, try to align the stabilization plane with as much content as possible because all the content on this plane is perfectly stabilized.</span></span>

<span data-ttu-id="bba6e-279">예:</span><span class="sxs-lookup"><span data-stu-id="bba6e-279">For example:</span></span>
* <span data-ttu-id="bba6e-280">평면 콘텐츠(앱 읽기, 비디오 재생 앱)만 있는 경우 안정화 평면을 콘텐츠가 있는 평면에 맞춥다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-280">If you have only planar content (reading app, video playback app), align the stabilization plane with the plane that has your content.</span></span>
* <span data-ttu-id="bba6e-281">세 개의 작은 구가 잠겨 있는 경우 현재 사용자 보기에 있는 모든 구의 중심을 통해 안정화 평면을 "잘라내기"로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-281">If there are three small spheres that are world-locked, make the stabilization plane "cut" though the centers of all the spheres that are currently in the user's view.</span></span>
* <span data-ttu-id="bba6e-282">장면에 상당히 다른 깊이의 콘텐츠가 있는 경우 추가 개체를 선호합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-282">If your scene has content at substantially different depths, favor further objects.</span></span>
* <span data-ttu-id="bba6e-283">사용자가 보고 있는 홀로그램과 일치하도록 모든 프레임의 안정화 지점을 조정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-283">Make sure to adjust the stabilization point every frame to coincide with the hologram the user is looking at</span></span>

<span data-ttu-id="bba6e-284">**피해야 할 사항** 안정화 평면은 안정적인 홀로그램을 달성할 수 있는 훌륭한 도구이지만 오용되면 심각한 이미지 불안정이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-284">**Things to Avoid** The stabilization plane is a great tool to achieve stable holograms, but if misused it can result in severe image instability.</span></span>
* <span data-ttu-id="bba6e-285">"fire and forget"을 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="bba6e-285">Don't "fire and forget".</span></span> <span data-ttu-id="bba6e-286">사용자 뒤의 안정화 평면으로 끝나거나 더 이상 사용자 보기에 없는 개체에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-286">You can end up with the stabilization plane behind the user or attached to an object that is no longer in the user's view.</span></span> <span data-ttu-id="bba6e-287">안정화 평면 표준이 카메라 정방향 반대쪽(예: -camera.forward)으로 설정되어 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-287">Ensure the stabilization plane normal is set opposite camera-forward (for example, -camera.forward)</span></span>
* <span data-ttu-id="bba6e-288">극단 간 안정화 평면을 빠르게 변경하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="bba6e-288">Don't rapidly change the stabilization plane back and forth between extremes</span></span>
* <span data-ttu-id="bba6e-289">안정화 평면을 고정 거리/방향으로 설정하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="bba6e-289">Don't leave the stabilization plane set to a fixed distance/orientation</span></span>
* <span data-ttu-id="bba6e-290">안정화 평면이 사용자를 통과하도록 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="bba6e-290">Don't let the stabilization plane cut through the user</span></span>
* <span data-ttu-id="bba6e-291">HoloLens가 아닌 데스크톱 PC에서 실행할 때 포커스 지점을 설정하지 말고 픽셀 단위 깊이 기반 다시 프로젝션을 대신 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="bba6e-291">Don't set the focus point when running on a desktop PC rather than a HoloLens, and instead rely on per-pixel depth-based reprojection.</span></span>

## <a name="color-separation"></a><span data-ttu-id="bba6e-292">색 구분</span><span class="sxs-lookup"><span data-stu-id="bba6e-292">Color separation</span></span> 

<span data-ttu-id="bba6e-293">HoloLens 표시의 특성 때문에 "색 구분"이라는 아티팩트도 인식될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-293">Because of the nature of HoloLens displays, an artifact called "color-separation" can sometimes be perceived.</span></span> <span data-ttu-id="bba6e-294">개별 기본 색(빨강, 녹색 및 파랑)으로 구분된 이미지로 매니페스트됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-294">It manifests as the image separating into individual base colors - red, green, and blue.</span></span> <span data-ttu-id="bba6e-295">아티팩트에서는 빨간색, 녹색 및 파랑이 많기 때문에 흰색 개체를 표시할 때 특히 표시될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-295">The artifact can be especially visible when displaying white objects, since they have large amounts of red, green, and blue.</span></span> <span data-ttu-id="bba6e-296">사용자가 홀로그램 프레임을 고속으로 이동하는 홀로그램을 시각적으로 추적하는 경우 가장 두드러집니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-296">It's most pronounced when a user visually tracks a hologram that is moving across the holographic frame at high speed.</span></span> <span data-ttu-id="bba6e-297">아티팩트에서 매니페스트할 수 있는 또 다른 방법은 개체의 변형/변형입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-297">Another way the artifact can manifest is warping/deformation of objects.</span></span> <span data-ttu-id="bba6e-298">개체에 고대비 및/또는 순수 색(예: 빨강, 녹색, 파랑, 색 구분)이 있는 경우 개체의 여러 부분에 대한 변형으로 인식됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-298">If an object has high contrast and/or pure colors such as red, green, blue, color-separation will be perceived as warping of different parts of the object.</span></span>

<span data-ttu-id="bba6e-299">**머리가 잠긴 흰색 둥근 커서의 색 구분은 사용자가 헤드를 측면으로 회전할 때의 예입니다.**</span><span class="sxs-lookup"><span data-stu-id="bba6e-299">**Example of what the color separation of a head-locked white round cursor could look like as a user rotates their head to the side:**</span></span>

![머리가 잠긴 흰색 둥근 커서의 색 구분 예는 사용자가 헤드를 측면으로 회전할 때의 모양입니다.](images/colorseparationofroundwhitecursor-300px.png)

<span data-ttu-id="bba6e-301">색 분리를 완전히 피하는 것이 어렵기는 하지만이를 완화 하는 데 사용할 수 있는 몇 가지 기술이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-301">Though it's difficult to completely avoid color separation, there are several techniques available to mitigate it.</span></span>

<span data-ttu-id="bba6e-302">**색 구분은 다음에 표시 될 수 있습니다.**</span><span class="sxs-lookup"><span data-stu-id="bba6e-302">**Color-separation can be seen on:**</span></span>
* <span data-ttu-id="bba6e-303">[커서](../../design/cursors.md)와 같은 헤드가 잠긴 개체를 포함 하 여 빠르게 이동 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-303">Objects that are moving quickly, including head-locked objects such as the [cursor](../../design/cursors.md).</span></span>
* <span data-ttu-id="bba6e-304">[안정화 평면과](hologram-stability.md#reprojection)크게 떨어져 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-304">Objects that are substantially far from the [stabilization plane](hologram-stability.md#reprojection).</span></span>

<span data-ttu-id="bba6e-305">**색 구분의 영향을 경우:**</span><span class="sxs-lookup"><span data-stu-id="bba6e-305">**To attenuate the effects of color-separation:**</span></span>
* <span data-ttu-id="bba6e-306">개체가 사용자의 응시로 지연 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-306">Make the object lag the user's gaze.</span></span> <span data-ttu-id="bba6e-307">일부 관성이 있고 응시 "스프링"에 연결 된 것 처럼 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-307">It should appear as if it has some inertia and is attached to the gaze "on springs".</span></span> <span data-ttu-id="bba6e-308">이 접근 방식은 커서를 천천히 만들고 (분리 거리를 줄여) 사용자의 응시 지점 뒤에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-308">This approach slows the cursor (reducing separation distance) and puts it behind the user's likely gaze point.</span></span> <span data-ttu-id="bba6e-309">사용자가이를 신속 하 게 파악 하는 경우에는 사용자가 응시를 중지 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-309">So long as it quickly catches up when the user stops shifting their gaze it feels natural.</span></span>
* <span data-ttu-id="bba6e-310">홀로그램을 이동 하려는 경우 사용자가 눈동자를 따르도록 하려면 이동 속도를 5도 이하로 유지 하세요.</span><span class="sxs-lookup"><span data-stu-id="bba6e-310">If you do want to move a hologram, try to keep its movement speed below 5 degrees/second if you expect the user to follow it with their eyes.</span></span>
* <span data-ttu-id="bba6e-311">커서에 기 하 *도형* 대신 *라이트* 를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-311">Use *light* instead of *geometry* for the cursor.</span></span> <span data-ttu-id="bba6e-312">응시에 연결 된 가상 조명 원본은 대화형 포인터로 인식 되지만 색 구분이 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-312">A source of virtual illumination attached to the gaze will be perceived as an interactive pointer but won't cause color-separation.</span></span>
* <span data-ttu-id="bba6e-313">사용자가 gazing에 있는 holograms 일치 하도록 안정화 평면을 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-313">Adjust the stabilization plane to match the holograms the user is gazing at.</span></span>
* <span data-ttu-id="bba6e-314">개체를 빨간색, 녹색 또는 파란색으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-314">Make the object red, green, or blue.</span></span>
* <span data-ttu-id="bba6e-315">콘텐츠를 흐린 버전으로 전환 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-315">Switch to a blurred version of the content.</span></span> <span data-ttu-id="bba6e-316">예를 들어, 둥근 흰색 커서는 동작 방향을 중심으로 약간 흐리게 된 선으로 변경 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-316">For example, a round white cursor could be changed to a slightly blurred line oriented in the direction of motion.</span></span>

<span data-ttu-id="bba6e-317">이전과 마찬가지로 60 FPS에서 렌더링 하 고 안정화 평면을 설정 하는 것은 홀로그램 안정성을 위한 가장 중요 한 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-317">As before, rendering at 60 FPS and setting the stabilization plane are the most important techniques for hologram stability.</span></span> <span data-ttu-id="bba6e-318">눈에 띄는 색 분리를 사용 하는 경우 먼저 프레임 속도에 기대를 충족 하는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="bba6e-318">If facing noticeable color separation, first make sure the frame rate meets expectations.</span></span>

## <a name="see-also"></a><span data-ttu-id="bba6e-319">참조</span><span class="sxs-lookup"><span data-stu-id="bba6e-319">See also</span></span>
* [<span data-ttu-id="bba6e-320">혼합 현실 성능 이해</span><span class="sxs-lookup"><span data-stu-id="bba6e-320">Understanding Performance for Mixed Reality</span></span>](understanding-performance-for-mixed-reality.md)
* [<span data-ttu-id="bba6e-321">색, 광원 및 재질</span><span class="sxs-lookup"><span data-stu-id="bba6e-321">Color, light, and materials</span></span>](../../design/color-light-and-materials.md)
* [<span data-ttu-id="bba6e-322">Instinctual 상호 작용</span><span class="sxs-lookup"><span data-stu-id="bba6e-322">Instinctual interactions</span></span>](../../design/interaction-fundamentals.md)
* [<span data-ttu-id="bba6e-323">MRTK 홀로그램 안정화</span><span class="sxs-lookup"><span data-stu-id="bba6e-323">MRTK Hologram Stabilization</span></span>](/windows/mixed-reality/mrtk-unity/performance/hologram-stabilization)