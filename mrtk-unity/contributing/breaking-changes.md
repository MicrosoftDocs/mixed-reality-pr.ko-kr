---
title: 호환성이 손상되는 변경
description: MRTK의 주요 변경 내용에 대한 정책입니다.
author: polar-kev
ms.author: kesemple
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, Mixed Reality, 개발, MRTK
ms.openlocfilehash: 4cd5e0b085a182377aacdf35e1298ad1180ee641
ms.sourcegitcommit: f338b1f121a10577bcce08a174e462cdc86d5874
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/01/2021
ms.locfileid: "113177269"
---
# <a name="breaking-changes"></a><span data-ttu-id="abd13-104">주요 변경 내용</span><span class="sxs-lookup"><span data-stu-id="abd13-104">Breaking changes</span></span>

<span data-ttu-id="abd13-105">MRTK의 소비자는 안정적인 릴리스-릴리스 API 표면을 사용하여 매번 큰 주요 변경 없이 MRTK를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-105">Consumers of the MRTK depend on having a stable release-to-release API surface, so that they can take updates to the MRTK without having large breaking changes each time.</span></span>

<span data-ttu-id="abd13-106">이 페이지에서는 MRTK의 주요 변경 내용에 대한 현재 정책과 주요 변경 내용을 낮게 유지하고 코드에 대한 적절한 장기적인 기술적 변경을 할 수 있는 방법 간의 장단점에 대한 몇 가지 장기적인 목표를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-106">This page describes our current policy regarding breaking changes in the MRTK, along with some longer term goals around how we can better manage the tradeoff between keeping breaking changes low and being able to make the right long term technical changes to the code.</span></span>

## <a name="what-is-a-breaking-change"></a><span data-ttu-id="abd13-107">주요 변경 내용이란?</span><span class="sxs-lookup"><span data-stu-id="abd13-107">What is a breaking change?</span></span>

<span data-ttu-id="abd13-108">[목록 A의](#list-a) 조건을 충족하고 목록 [B의](#list-b) 모든 조건을 충족하는 경우 변경은 주요 변경입니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-108">A change is a breaking change if it satisfies any of the conditions in the [List A](#list-a) AND satisfies all of the conditions in [list B](#list-b)</span></span>

### <a name="list-a"></a><span data-ttu-id="abd13-109">목록 A</span><span class="sxs-lookup"><span data-stu-id="abd13-109">List A</span></span>

- <span data-ttu-id="abd13-110">인터페이스의 멤버 또는 함수의 추가, 제거 또는 업데이트(또는 전체 인터페이스의 제거/이름 바꾸기)입니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-110">The addition, removal, or update of any member or function of any interface (or removal/rename of the entire interface).</span></span>
- <span data-ttu-id="abd13-111">클래스의 보호된 멤버 또는 public 멤버 또는 함수의 제거, 업데이트(형식/정의 변경, private 또는 internal 만들기)입니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-111">The removal, update (changing type/definition, making private or internal) of any protected or public member or function of class.</span></span> <span data-ttu-id="abd13-112">(또는 전체 클래스의 제거/이름 바꾸기).</span><span class="sxs-lookup"><span data-stu-id="abd13-112">(or removal/rename of the entire class).</span></span>
- <span data-ttu-id="abd13-113">클래스에서 발생한 이벤트 순서의 변경입니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-113">The change in the order of events fired by a class.</span></span>
- <span data-ttu-id="abd13-114">ScriptableObject에서 프라이빗 SerializedField(해당 FormerlySerializedAs 태그 제외) 또는 공용 속성의 이름(특히 프로필 변경)의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-114">The rename of any private SerializedField (without a corresponding FormerlySerializedAs tag) or public property on a ScriptableObject (especially changes to profiles).</span></span>
- <span data-ttu-id="abd13-115">ScriptableObject에서 필드 형식 변경(특히 프로필 변경)</span><span class="sxs-lookup"><span data-stu-id="abd13-115">Changing the type of a field on a ScriptableObject (especially changes to profiles).</span></span>
- <span data-ttu-id="abd13-116">클래스 또는 인터페이스의 네임스페이스 또는 asmdef로 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-116">Updates to the namespace or asmdefs of any class or interface.</span></span>
- <span data-ttu-id="abd13-117">프리팹의 최상위 개체에서 모든 프리팹을 제거하거나 스크립트를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-117">Removal of any prefab or removal of a script on the top level object of a prefab.</span></span>

### <a name="list-b"></a><span data-ttu-id="abd13-118">목록 B</span><span class="sxs-lookup"><span data-stu-id="abd13-118">List B</span></span>

- <span data-ttu-id="abd13-119">해당 자산은 기본 패키지에 있습니다(즉, 다음 폴더 중 하나에 있음).</span><span class="sxs-lookup"><span data-stu-id="abd13-119">The asset in question is in the foundation package (i.e. it's in one of the following folders):</span></span>

  - <span data-ttu-id="abd13-120">MRTK/Core</span><span class="sxs-lookup"><span data-stu-id="abd13-120">MRTK/Core</span></span>
  - <span data-ttu-id="abd13-121">MRTK/Providers/</span><span class="sxs-lookup"><span data-stu-id="abd13-121">MRTK/Providers/</span></span>
  - <span data-ttu-id="abd13-122">MRTK/Services/</span><span class="sxs-lookup"><span data-stu-id="abd13-122">MRTK/Services/</span></span>
  - <span data-ttu-id="abd13-123">MRTK/SDK/</span><span class="sxs-lookup"><span data-stu-id="abd13-123">MRTK/SDK/</span></span>
  - <span data-ttu-id="abd13-124">MRTK/확장</span><span class="sxs-lookup"><span data-stu-id="abd13-124">MRTK/Extensions</span></span>

- <span data-ttu-id="abd13-125">해당 자산이 실험적 네임스페이스에 속하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-125">The asset in question does not belong to the experimental namespace.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="abd13-126">예제 패키지(즉, MRTK/Examples/ 폴더의 일부)에 있는 모든 자산은 소비자가 '참조 구현'으로 복사하고 볼 수 있도록 설계되었지만 API 및 자산의 핵심 집합에 포함되지 않기 때문에 언제든지 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-126">Any asset that sits in the examples package (i.e. part of the MRTK/Examples/ folder) is subject to change at any time, as assets there are designed to be copied and viewed by consumers as 'reference implementations' but are not part of the core set of APIs and assets.</span></span> <span data-ttu-id="abd13-127">실험적 네임스페이스의 자산(또는 일반적으로 실험적으로 레이블이 지정된 기능)은 모든 실사가 완료되기 전에 게시되는 자산(예: 테스트, UX 반복, 설명서)이며 피드백을 더 빨리 얻기 위해 조기에 게시됩니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-127">Assets in the experimental namespace (or more generally, features labelled as experimental) are ones that get published before all due diligence has been done (i.e. tests, UX iteration, documentation) and is published early to get feedback sooner.</span></span>  <span data-ttu-id="abd13-128">그러나 테스트 및 설명서가 없고 모든 상호 작용 및 디자인을 중단하지 않았을 가능성이 높기 때문에 퍼블릭이 변경될 수 있고 변경된다고 가정해야 하는 상태(즉, 수정, 완전히 제거 등)에 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-128">However, because they don't have tests and documentation, and because we likely haven't nailed down all of the interactions and designs, we publish them in a state where the public should assume that they can and will change (i.e. be modified, completely removed, etc).</span></span>
>
> <span data-ttu-id="abd13-129">자세한 내용은 [실험적 기능을](../contributing/experimental-features.md) 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="abd13-129">See [Experimental features](../contributing/experimental-features.md) for more information.</span></span>

<span data-ttu-id="abd13-130">주요 변경 내용에 대한 표면 영역이 매우 크기 때문에 "주요 변경 내용 없음"이라는 절대 규칙을 사용하는 것은 불가능합니다. 주요 변경 내용을 적용하여 온전한 방식으로만 수정할 수 있는 문제가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-130">As the surface area for breaking changes is very large, it's important to note that having an absolute rule that says "no breaking changes" would be impossible - there may be issues that can only be fixed in a sane way by having a breaking change.</span></span> <span data-ttu-id="abd13-131">다른 방법으로, 실제로 "주요 변경 내용 없음"을 가질 수 있는 유일한 방법은 전혀 변경하지 않는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-131">To put another way, the only way we could really have "no breaking changes" is to have no changes at all.</span></span>

<span data-ttu-id="abd13-132">당사의 기본 정책은 가능한 경우 주요 변경을 방지하고, 변경으로 상당한 고객 또는 프레임워크의 장기적인 가치가 발생하는 경우에만 이를 수행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-132">Our standing policy is to avoid making breaking changes if possible, and only do so if the change would accrue significant customer or framework long term value.</span></span>

## <a name="what-to-do-about-breaking-changes"></a><span data-ttu-id="abd13-133">주요 변경 내용에 대해 수행할 사항</span><span class="sxs-lookup"><span data-stu-id="abd13-133">What to do about breaking changes</span></span>

<span data-ttu-id="abd13-134">주요 변경 없이 기능의 장기적인 구조와 실행 가능성을 손상시키지 않고 작업을 수행할 수 있는 경우 주요 변경 작업을 수행하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="abd13-134">If it is possible to accomplish something without a breaking change and without compromising the long term structure and viability of the feature, don't do the breaking change.</span></span> <span data-ttu-id="abd13-135">다른 방법이 없는 경우 현재 정책은 각 개별 주요 변경을 평가하여 변경의 혜택이 변경에 대한 소비자의 비용보다 큰지 파악하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-135">If there is no other way, the current policy is to evaluate each individual breaking change, to understand if the benefit from taking the change outweighs the cost to the consumer of absorbing the change.</span></span> <span data-ttu-id="abd13-136">가치 있는 일 및 일반적으로 PR 또는 문제 토론 자체에서 수행되지 않는 것에 대해 생각해보십시오.</span><span class="sxs-lookup"><span data-stu-id="abd13-136">Debate about what is worth doing and what isn't will generally take place on the PR or issue discussion itself.</span></span>

<span data-ttu-id="abd13-137">여기서 발생할 수 있는 일은 여러 버킷에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-137">What can happen here falls into several buckets:</span></span>

### <a name="the-breaking-change-adds-value-but-could-be-written-in-a-way-that-isnt-breaking"></a><span data-ttu-id="abd13-138">주요 변경으로 인해 값이 추가되지만 주요 변경 내용이 아닌 방식으로 작성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-138">The breaking change adds value but could be written in a way that isn't breaking</span></span>

<span data-ttu-id="abd13-139">예를 들어 [이 PR은](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) 기존 인터페이스를 수정하는 방식으로 처음에 작성된 새 기능을 추가했지만, 해당 기능이 자체 인터페이스로 분리된 위치에 다시 작성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-139">For example, [this PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) added a new feature that was initially written in a way that was breaking - it modified an existing interface - but was then rewritten where the feature was broken out as its own interface.</span></span> <span data-ttu-id="abd13-140">이는 일반적으로 최상의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-140">This is generally the best possible outcome.</span></span> <span data-ttu-id="abd13-141">이렇게 하면 기능의 장기적인 실행 가능성 또는 구조가 손상될 경우 변경 작업을 강제로 중단하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="abd13-141">Do not try to force a change into a non-breaking form if doing so would compromise the long term viability or structure of the feature.</span></span>

### <a name="the-breaking-change-adds-sufficient-value-to-the-customer-that-its-worth-doing"></a><span data-ttu-id="abd13-142">주요 변경으로 고객에게 가치 있는 가치가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-142">The breaking change adds sufficient value to the customer that it's worth doing</span></span>

<span data-ttu-id="abd13-143">주요 변경 내용을 문서화하고 가능한 최상의 완화 방법(즉, 마이그레이션 방법에 대한 규범적 단계 또는 고객을 위해 자동으로 마이그레이션되는 더 나은 아직 도구)을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-143">Document what the breaking changes are and provide the best possible mitigation (i.e. prescriptive steps on how to migrate, or better yet tooling that will automatically migrate for the customer).</span></span> <span data-ttu-id="abd13-144">각 릴리스에는 중단되는 약간의 변경 내용이 포함될 수 있습니다. 이러한 변경 내용은 [이 PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858)에서 수행한 대로 항상 문서에 설명되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-144">Each release may contain a small amount of changes that are breaking - these should always be documented in docs as was done in [this PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858).</span></span> <span data-ttu-id="abd13-145">2.x.x→2.x+1.x+1 마이그레이션 가이드가 이미 있는 경우 해당 문서에 지침 또는 도구를 추가합니다. 존재하지 않는 경우 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-145">If there already is a 2.x.x→2.x+1.x+1 migration guide, then add instructions or tooling to that doc. If it doesn't exist, create it.</span></span>

### <a name="the-breaking-change-adds-value-but-the-customer-pain-would-be-too-high"></a><span data-ttu-id="abd13-146">주요 변경으로 가치를 더하지만 고객의 불만은 너무 높아질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-146">The breaking change adds value but the customer pain would be too high</span></span>

<span data-ttu-id="abd13-147">모든 유형의 주요 변경 내용이 동일하게 만들어지는 것은 아닙니다. 일부는 경험에 따라 고객 경험을 기반으로 하는 다른 변경 내용에 훨씬 더 큰 만족을 겪습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-147">Not all types of breaking changes are created equal - some are significantly more painful that others, based on our experience and based on customer experiences.</span></span> <span data-ttu-id="abd13-148">예를 들어 인터페이스에 대한 변경은 어려울 수 있지만, 주요 변경 내용이 고객이 과거에 확장/구현될 가능성이 없는 경우(예: 진단 시각화 시스템) 실제 비용은 매우 낮을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-148">For example, changes to interfaces may be painful, but if the breaking change is one in which a customer is unlikely to have extended/implemented in the past (the diagnostic visualization system, for example), then the actual cost is probably low to nothing.</span></span> <span data-ttu-id="abd13-149">그러나 변경 내용이 ScriptableObject의 필드 형식(예: MRTK의 핵심 프로필 중 하나)인 경우 이로 인해 고객에게 큰 불만의 원인이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-149">However, if the change is the type of a field on a ScriptableObject (for example, on one of the core profiles of the MRTK), this is likely to cause massive customer pain.</span></span> <span data-ttu-id="abd13-150">고객이 이미 기본 프로필을 복제했으며, 프로필 병합/업데이트는 수동으로(예: 병합 시간 동안 텍스트 편집기를 통해) 매우 어려울 수 있으며, 기본 프로필을 다시 복사하고 모든 항목을 직접 다시 구성하면 회귀를 디버깅하기 어려울 가능성이 매우 높습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-150">Customers have already cloned the default profile, merging/updating profiles can be extremely hard to do manually (i.e. via a text editor during merge time), and re-copying the default profile and reconfiguring everything by hand is extremely likely to lead to hard to debug regressions.</span></span>

<span data-ttu-id="abd13-151">이러한 변경 내용은 고객에게 업그레이드 이유를 제공하는 중요한 가치와 함께 크게 주요 변경 내용을 허용하는 분기가 존재할 때까지 다시 기존에 배치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-151">These changes we have to put back onto the shelf until a branch exists that will allow significantly breaking changes (along with significant value that will give customers a reason to upgrade).</span></span> <span data-ttu-id="abd13-152">이러한 분기는 현재 존재하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-152">Such a branch doesn't currently exist.</span></span> <span data-ttu-id="abd13-153">향후 반복 계획 회의에서는 '너무 중단'되었던 변경/문제 세트를 검토하여 한 번에 변경 집합을 진행하는 것이 합리적일 수 있도록 중요한 대용량에 도달했는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-153">In our future iteration planning meetings, we will review the set of changes/issues that were 'too breaking' to see if we reached a critical mass to make it reasonable to pursue a set of changes all at once.</span></span> <span data-ttu-id="abd13-154">보유하고 있는 엔지니어링 리소스가 제한되고 테스트와 유효성 검사를 분할해야 한다는 사실 때문에 실사 없이 "모든 것이 허용됨" 분기를 스핀업하는 것은 위험합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-154">Note that it's dangerous to spin up a "everything is allowed" branch without due diligence being done because of the limited engineering resources we have, and the fact that we'd have to split testing and validation across those two.</span></span> <span data-ttu-id="abd13-155">이러한 분기가 있는 경우 명확한 목적과 잘 전달된 시작 및 종료 날짜가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-155">There needs to be a clear purpose and well-communicated start and end date of such a branch when it exists.</span></span>

## <a name="long-term-management-of-breaking-changes"></a><span data-ttu-id="abd13-156">주요 변경 내용의 장기 관리</span><span class="sxs-lookup"><span data-stu-id="abd13-156">Long term management of breaking changes</span></span>

<span data-ttu-id="abd13-157">장기적으로 [목록 B에서](#list-b)조건 집합을 늘려서 주요 변경 내용의 범위를 줄이려고 노력해야 합니다. 앞으로 [목록 A의](#list-a) 항목 집합은 "공용 API 표면"에 있는 것으로 간주되는 파일 및 자산 집합에 대해 항상 기술적으로 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-157">In the long term, we should seek to reduce the scope of what is a breaking change by increasing the set of conditions in [List B](#list-b). Going forward the set of things in [List A](#list-a) will always technically be breaking for the set of files and assets that we deem to be in the "public API surface."</span></span> <span data-ttu-id="abd13-158">반복을 좀 더 자유롭게 할 수 있는 방법(즉, 내부 구현 세부 정보를 변경하여 여러 클래스 간에 코드를 보다 쉽게 리팩터링하고 공유할 수 있도록 허용)은 구현 세부 정보보다는 코드의 어느 부분이 공식적인 표면인지에 대해 더 명시적이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-158">The way that we can get a little more freedom for iteration (i.e. changing up the internal implementation details, allowing for easier refactoring and sharing of code between multiple classes, etc) is to be more explicit about which portions of the code are official surface, rather than implementation detail.</span></span>

<span data-ttu-id="abd13-159">이미 수행한 한 가지 작업은 "실험적" 기능의 개념을 소개하는 것입니다(실험적 네임스페이스에 속하고, 테스트/설명서가 없을 수 있으며, 공개적으로 존재하지만 경고 없이 제거 및 업데이트될 수 있음).</span><span class="sxs-lookup"><span data-stu-id="abd13-159">One thing we've already done is introduce the concept of an "experimental" feature (it belongs in the experimental namespace, it may not have tests/documentation, and is publicly proclaimed to exist but may be removed and updated without warning).</span></span> <span data-ttu-id="abd13-160">이로 인해 새 기능을 더 빨리 추가하여 이전 피드백을 받을 수 있지만 API 표면을 완전히 파악하지 않았을 수 있으므로 해당 API 표면과 즉시 연결되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-160">This has given has freedom to add new features sooner to get earlier feedback, but not be immediately tied to its API surface (because we may not have fully thought out the API surface).</span></span>

### <a name="other-examples-of-things-that-could-help-in-the-future"></a><span data-ttu-id="abd13-161">나중에 도움이 될 수 있는 기타 예제</span><span class="sxs-lookup"><span data-stu-id="abd13-161">Other examples of things that could help in the future</span></span>

- <span data-ttu-id="abd13-162">[내부 키워드](/dotnet/csharp/language-reference/keywords/internal)의 사용법입니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-162">Usage of the [internal keyword](/dotnet/csharp/language-reference/keywords/internal).</span></span>
  <span data-ttu-id="abd13-163">이렇게 하면 외부 소비자에게 공개하지 않고도 자체 어셈블리 내에서 공유 코드를 가질 수 있습니다(코드 중복을 줄이기 위해).</span><span class="sxs-lookup"><span data-stu-id="abd13-163">This would allow for us to have shared code within our own assemblies (for reducing code duplication) without making things public to external consumers.</span></span>
- <span data-ttu-id="abd13-164">"내부" 네임스페이스 만들기(예: Microsoft.MixedReality.Toolkit. Internal.Utilities) - 내부 네임스페이스 내에 포함된 모든 항목은 언제든지 변경될 수 있으며 제거될 수 있음을 공개적으로 문서화합니다. 이는 C++ 헤더 라이브러리가 ::internal 네임스페이스를 사용하여 구현 세부 정보를 숨기는 방법과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="abd13-164">Creation of an "internal" namespace (i.e. Microsoft.MixedReality.Toolkit.Internal.Utilities), where we publicly document that anything contained within that internal namespace is subject to change at anytime and could be removed, etc. This is similar to how C++ header libraries will make use of ::internal namespaces to hide their implementation details.</span></span>
