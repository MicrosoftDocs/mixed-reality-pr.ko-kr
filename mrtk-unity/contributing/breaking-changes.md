---
title: 호환성이 손상되는 변경
description: MRTK의 주요 변경 내용에 대한 정책입니다.
author: polar-kev
ms.author: kesemple
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, Mixed Reality, 개발, MRTK
ms.openlocfilehash: 713cb5a0965d713c7073004059218ab2ab37201d
ms.sourcegitcommit: 8b4c2b1aac83bc8adf46acfd92b564f899ef7735
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/30/2021
ms.locfileid: "113121551"
---
# <a name="breaking-changes"></a>주요 변경 내용

MRTK의 소비자는 안정적인 릴리스-릴리스 API 표면을 사용하여 매번 큰 주요 변경 없이 MRTK를 업데이트할 수 있습니다.

이 페이지에서는 MRTK의 주요 변경 내용에 대한 현재 정책과 주요 변경 내용을 낮게 유지하고 코드에 대한 적절한 장기적인 기술적 변경을 할 수 있는 방법 간의 장단점에 대한 몇 가지 장기적인 목표를 설명합니다.

## <a name="what-is-a-breaking-change"></a>주요 변경 내용이란?

[목록 A의](#list-a) 조건을 충족하고 목록 [B의](#list-b) 모든 조건을 충족하는 경우 변경은 주요 변경입니다.

### <a name="list-a"></a>목록 A

- 인터페이스의 멤버 또는 함수의 추가, 제거 또는 업데이트(또는 전체 인터페이스의 제거/이름 바꾸기)입니다.
- 클래스의 보호된 멤버 또는 public 멤버 또는 함수의 제거, 업데이트(형식/정의 변경, private 또는 internal 만들기)입니다. (또는 전체 클래스의 제거/이름 바꾸기).
- 클래스에서 발생한 이벤트 순서의 변경입니다.
- ScriptableObject에서 프라이빗 SerializedField(해당 FormerlySerializedAs 태그 제외) 또는 공용 속성의 이름(특히 프로필 변경)의 이름입니다.
- ScriptableObject에서 필드 형식 변경(특히 프로필 변경)
- 클래스 또는 인터페이스의 네임스페이스 또는 asmdef로 업데이트합니다.
- 프리팹의 최상위 개체에서 모든 프리팹을 제거하거나 스크립트를 제거합니다.

### <a name="list-b"></a>목록 B

- 해당 자산은 기본 패키지에 있습니다(즉, 다음 폴더 중 하나에 있음).

  - MRTK/Core
  - MRTK/Providers/
  - MRTK/Services/
  - MRTK/SDK/
  - MRTK/확장

- 해당 자산이 실험적 네임스페이스에 속하지 않습니다.

> [!IMPORTANT]
> 예제 패키지(즉, MRTK/Examples/ 폴더의 일부)에 있는 모든 자산은 소비자가 '참조 구현'으로 복사하고 볼 수 있도록 설계되었지만 API 및 자산의 핵심 집합에 포함되지 않기 때문에 언제든지 변경될 수 있습니다. 실험적 네임스페이스의 자산(또는 일반적으로 실험적으로 레이블이 지정된 기능)은 모든 실사가 완료되기 전에 게시되는 자산(예: 테스트, UX 반복, 설명서)이며 피드백을 더 빨리 얻기 위해 조기에 게시됩니다.  그러나 테스트 및 설명서가 없고 모든 상호 작용 및 디자인을 중단하지 않았을 가능성이 높기 때문에 퍼블릭이 변경될 수 있고 변경된다고 가정해야 하는 상태(즉, 수정, 완전히 제거 등)에 게시합니다.
>
> 자세한 내용은 [실험적 기능을](../contributing/experimental-features.md) 참조하세요.

주요 변경 내용에 대한 표면 영역이 매우 크기 때문에 "주요 변경 내용 없음"이라는 절대 규칙을 사용하는 것은 불가능합니다. 주요 변경 내용을 적용하여 온전한 방식으로만 수정할 수 있는 문제가 있을 수 있습니다. 다른 방법으로, 실제로 "주요 변경 내용 없음"을 가질 수 있는 유일한 방법은 전혀 변경하지 않는 것입니다.

당사의 기본 정책은 가능한 경우 주요 변경을 방지하고, 변경으로 상당한 고객 또는 프레임워크의 장기적인 가치가 발생하는 경우에만 이를 수행하는 것입니다.

## <a name="what-to-do-about-breaking-changes"></a>주요 변경 내용에 대해 수행할 사항

주요 변경 없이 기능의 장기적인 구조와 실행 가능성을 손상시키지 않고 작업을 수행할 수 있는 경우 주요 변경 작업을 수행하지 마세요. 다른 방법이 없는 경우 현재 정책은 각 개별 주요 변경을 평가하여 변경의 혜택이 변경에 대한 소비자의 비용보다 큰지 파악하는 것입니다. 가치 있는 일 및 일반적으로 PR 또는 문제 토론 자체에서 수행되지 않는 것에 대해 생각해보십시오.

여기서 발생할 수 있는 일은 여러 버킷에 해당합니다.

### <a name="the-breaking-change-adds-value-but-could-be-written-in-a-way-that-isnt-breaking"></a>주요 변경으로 인해 값이 추가되지만 주요 변경 내용이 아닌 방식으로 작성될 수 있습니다.

예를 들어 [이 PR은](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) 기존 인터페이스를 수정하는 방식으로 처음에 작성된 새 기능을 추가했지만, 해당 기능이 자체 인터페이스로 분리된 위치에 다시 작성되었습니다. 이는 일반적으로 최상의 결과입니다. 이렇게 하면 기능의 장기적인 실행 가능성 또는 구조가 손상될 경우 변경 작업을 강제로 중단하지 마십시오.

### <a name="the-breaking-change-adds-sufficient-value-to-the-customer-that-its-worth-doing"></a>주요 변경으로 고객에게 가치 있는 가치가 추가됩니다.

주요 변경 내용을 문서화하고 가능한 최상의 완화 방법(즉, 마이그레이션 방법에 대한 규범적 단계 또는 고객을 위해 자동으로 마이그레이션되는 더 나은 아직 도구)을 제공합니다. 각 릴리스에는 중단되는 약간의 변경 내용이 포함될 수 있습니다. 이러한 변경 내용은 [이 PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858)에서 수행한 대로 항상 문서에 설명되어 있어야 합니다. 2.x.x→2.x+1.x+1 마이그레이션 가이드가 이미 있는 경우 해당 문서에 지침 또는 도구를 추가합니다. 존재하지 않는 경우 만듭니다.

### <a name="the-breaking-change-adds-value-but-the-customer-pain-would-be-too-high"></a>주요 변경으로 가치를 더하지만 고객의 불만은 너무 높아질 수 있습니다.

모든 유형의 주요 변경 내용이 동일하게 만들어지는 것은 아닙니다. 일부는 경험에 따라 고객 경험을 기반으로 하는 다른 변경 내용에 훨씬 더 큰 만족을 겪습니다. 예를 들어 인터페이스에 대한 변경은 어려울 수 있지만, 주요 변경 내용이 고객이 과거에 확장/구현될 가능성이 없는 경우(예: 진단 시각화 시스템) 실제 비용은 매우 낮을 수 있습니다. 그러나 변경 내용이 ScriptableObject의 필드 형식(예: MRTK의 핵심 프로필 중 하나)인 경우 이로 인해 고객에게 큰 불만의 원인이 될 수 있습니다. 고객이 이미 기본 프로필을 복제했으며, 프로필 병합/업데이트는 수동으로(예: 병합 시간 동안 텍스트 편집기를 통해) 매우 어려울 수 있으며, 기본 프로필을 다시 복사하고 모든 항목을 직접 다시 구성하면 회귀를 디버깅하기 어려울 가능성이 매우 높습니다.

이러한 변경 내용은 고객에게 업그레이드 이유를 제공하는 중요한 가치와 함께 크게 주요 변경 내용을 허용하는 분기가 존재할 때까지 다시 기존에 배치해야 합니다. 이러한 분기는 현재 존재하지 않습니다. 향후 반복 계획 회의에서는 '너무 중단'되었던 변경/문제 세트를 검토하여 한 번에 변경 집합을 진행하는 것이 합리적일 수 있도록 중요한 대용량에 도달했는지 확인합니다. 보유하고 있는 엔지니어링 리소스가 제한되고 테스트와 유효성 검사를 분할해야 한다는 사실 때문에 실사 없이 "모든 것이 허용됨" 분기를 스핀업하는 것은 위험합니다. 이러한 분기가 있는 경우 명확한 목적과 잘 전달된 시작 및 종료 날짜가 있어야 합니다.

## <a name="long-term-management-of-breaking-changes"></a>주요 변경 내용의 장기 관리

장기적으로 [목록 B에서](#list-b)조건 집합을 늘려서 주요 변경 내용의 범위를 줄이려고 노력해야 합니다. 앞으로 [목록 A의](#list-a) 항목 집합은 "공용 API 표면"에 있는 것으로 간주되는 파일 및 자산 집합에 대해 항상 기술적으로 중단됩니다. 반복을 좀 더 자유롭게 할 수 있는 방법(즉, 내부 구현 세부 정보를 변경하여 여러 클래스 간에 코드를 보다 쉽게 리팩터링하고 공유할 수 있도록 허용)은 구현 세부 정보보다는 코드의 어느 부분이 공식적인 표면인지에 대해 더 명시적이어야 합니다.

이미 수행한 한 가지 작업은 "실험적" 기능의 개념을 소개하는 것입니다(실험적 네임스페이스에 속하고, 테스트/설명서가 없을 수 있으며, 공개적으로 존재하지만 경고 없이 제거 및 업데이트될 수 있음). 이로 인해 새 기능을 더 빨리 추가하여 이전 피드백을 받을 수 있지만 API 표면을 완전히 파악하지 않았을 수 있으므로 해당 API 표면과 즉시 연결되지는 않습니다.

### <a name="other-examples-of-things-that-could-help-in-the-future"></a>나중에 도움이 될 수 있는 기타 예제

- [내부 키워드](/dotnet/csharp/language-reference/keywords/internal)의 사용법입니다.
  이렇게 하면 외부 소비자에게 공개하지 않고도 자체 어셈블리 내에서 공유 코드를 가질 수 있습니다(코드 중복을 줄이기 위해).
- "내부" 네임스페이스 만들기(예: Microsoft.MixedReality.Toolkit.Internal.Utilities) 여기서 해당 내부 네임스페이스 내에 포함된 모든 항목은 언제든지 변경될 수 있으며 제거될 수 있음을 공개적으로 문서화합니다. 이는 C++ 헤더 라이브러리가 ::internal 네임스페이스를 사용하여 구현 세부 정보를 숨기는 방법과 비슷합니다.