---
title: 주요 변경 내용
description: MRTK의 주요 변경 내용에 대한 정책입니다.
author: polar-kev
ms.author: kesemple
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, Mixed Reality, 개발, MRTK
ms.openlocfilehash: 5f48503c4d28316cad49fbdf8bc163399ca9f7ad
ms.sourcegitcommit: c0ba7d7bb57bb5dda65ee9019229b68c2ee7c267
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/19/2021
ms.locfileid: "110143494"
---
# <a name="breaking-changes"></a>주요 변경 내용

MRTK의 소비자는 안정적인 릴리스-릴리스 API 표면을 사용하여 매번 큰 주요 변경 없이 MRTK를 업데이트할 수 있습니다.

이 페이지에서는 MRTK의 주요 변경 내용에 대한 현재 정책과 주요 변경 내용을 낮게 유지하고 코드에 대한 적절한 장기적인 기술적 변경을 할 수 있는 방법 간의 장단점에 대한 몇 가지 장기적인 목표를 설명합니다.

## <a name="what-is-a-breaking-change"></a>주요 변경 내용이란?

[목록 A의](#list-a) 조건을 충족하고 목록 [B의](#list-b) 모든 조건을 충족하는 경우 변경은 주요 변경입니다.

### <a name="list-a"></a>목록 A

- 인터페이스의 멤버 또는 함수의 추가, 제거 또는 업데이트(또는 전체 인터페이스의 제거/이름 바꾸기)입니다.
- 클래스의 보호된 멤버 또는 public 멤버 또는 함수의 제거, 업데이트(형식/정의 변경, private 또는 internal 만들기)입니다. (또는 전체 클래스의 제거/이름 바꾸기).
- 클래스에서 발생한 이벤트 순서의 변경입니다.
- ScriptableObject에서 프라이빗 SerializedField(해당 FormerlySerializedAs 태그 제외) 또는 공용 속성의 이름(특히 프로필 변경)의 이름입니다.
- ScriptableObject에서 필드 형식 변경(특히 프로필 변경)
- 클래스 또는 인터페이스의 네임스페이스 또는 asmdef로 업데이트합니다.
- 프리팹의 최상위 개체에서 모든 프리팹을 제거하거나 스크립트를 제거합니다.

### <a name="list-b"></a>목록 B

- 해당 자산은 기본 패키지에 있습니다(즉, 다음 폴더 중 하나에 있음).

  - MRTK/Core
  - MRTK/Providers/
  - MRTK/Services/
  - MRTK/SDK/
  - MRTK/Extensions

- 문제의 자산이 실험적 네임 스페이스에 속하지 않습니다.

> [!IMPORTANT]
> 예 패키지 (예: MRTK/예제/폴더의 일부)에 있는 자산은 언제 든 지 변경 될 수 있습니다 .이는 소비자가 ' 참조 구현 '으로 복사 하 고 볼 수 있도록 설계 되었지만 Api 및 자산의 핵심 집합에 포함 되지 않기 때문입니다. 실험적 네임 스페이스의 자산 (또는 일반적으로 실험적 이라고 하는 기능)은 모든 기한 성실 (예: 테스트, UX 반복, 설명서)가 완료 되기 전에 게시 되는 것 이며 빠르게 피드백을 얻기 위해 조기에 게시 됩니다.  그러나 사용자에 게는 테스트 및 설명서가 없으며 모든 상호 작용 및 디자인을 이죠 하지 않았기 때문에 공용에서이를 변경 하 고 변경 될 수 있다고 가정 하는 상태로 게시 합니다 (즉, 수정, 완전히 제거 등).
>
> 자세한 내용은 [실험적 기능](../contributing/experimental-features.md) 을 참조 하세요.

주요 변경 내용에 대 한 노출 영역이 매우 크기 때문에 "주요 변경 내용 없음"을 의미 하는 절대 규칙을 유지 하는 것은 불가능 합니다. 주요 변경 사항을 적용 하 여 sane 방식 으로만 해결할 수 있는 문제가 있을 수 있습니다. 또 다른 방법으로 "주요 변경 내용 없음"은 변경 하지 않아도 되는 유일한 방법입니다.

Microsoft의 고정 정책은 가능한 경우 주요 변경 사항을 방지 하 고 변경으로 인해 중요 한 고객 또는 프레임 워크 장기적인 가치를 계산 하는 경우에만 수행 하는 것입니다.

## <a name="what-to-do-about-breaking-changes"></a>주요 변경 내용에 대해 수행할 작업

주요 변경 없이 작업을 수행할 수 있고 장기적인 구조와 기능의 실행 가능성을 손상 시 키 지 않으면 주요 변경 작업을 수행 하지 않습니다. 다른 방법이 없는 경우 현재 정책은 각 개별 주요 변경 사항을 평가 하 여 변경의 이점을 흡수 소비자에 게 부과 하는 이점을 이해 하는 것입니다. 무엇을 할 만한 가치가 있으며 PR 또는 문제 토론 자체에서 일반적으로 수행 하지 않는 작업에 대해 논의 합니다.

여기서 발생할 수 있는 일은 여러 버킷에 해당합니다.

### <a name="the-breaking-change-adds-value-but-could-be-written-in-a-way-that-isnt-breaking"></a>주요 변경으로 인해 값이 추가되지만 주요 변경 내용이 아닌 방식으로 작성될 수 있습니다.

예를 들어 [이 PR은](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) 기존 인터페이스를 수정하는 방식으로 처음에 작성된 새 기능을 추가했지만, 해당 기능이 자체 인터페이스로 분리된 위치에 다시 작성되었습니다. 이는 일반적으로 최상의 결과입니다. 이렇게 하면 기능의 장기적인 실행 가능성 또는 구조가 손상될 경우 변경을 강제로 적용하지 마십시오.

### <a name="the-breaking-change-adds-sufficient-value-to-the-customer-that-its-worth-doing"></a>주요 변경으로 고객에게 가치 있는 가치가 추가됩니다.

주요 변경 내용을 문서화하고 가능한 최상의 완화 방법(즉, 마이그레이션 방법에 대한 규범적 단계 또는 고객을 위해 자동으로 마이그레이션되는 더 나은 아직 도구)을 제공합니다. 각 릴리스에는 중단되는 약간의 변경 내용이 포함될 수 있습니다. 이러한 변경 내용은 [이 PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858)에서 수행한 대로 항상 문서에 설명되어 있어야 합니다. 2.x.x→2.x+1.x+1 마이그레이션 가이드가 이미 있는 경우 해당 문서에 지침 또는 도구를 추가합니다. 존재하지 않는 경우 만듭니다.

### <a name="the-breaking-change-adds-value-but-the-customer-pain-would-be-too-high"></a>주요 변경으로 가치를 더하지만 고객의 불만은 너무 높아질 수 있습니다.

모든 유형의 주요 변경 내용이 동일하게 만들어지는 것은 아닙니다. 일부는 경험에 따라 고객 경험을 기반으로 하는 다른 변경 내용에 훨씬 더 큰 만족을 겪습니다. 예를 들어 인터페이스에 대한 변경은 어려울 수 있지만, 주요 변경 내용이 고객이 과거에 확장/구현될 가능성이 없는 경우(예: 진단 시각화 시스템) 실제 비용은 매우 낮을 수 있습니다. 그러나 변경 내용이 ScriptableObject의 필드 형식(예: MRTK의 핵심 프로필 중 하나)인 경우 이로 인해 고객에게 큰 불만의 원인이 될 수 있습니다. 고객은 이미 기본 프로필을 복제 했 고, 병합/업데이트 프로필은 수동으로 수행 하는 것이 매우 어려울 수 있습니다 (즉, 병합 시간 동안 텍스트 편집기를 통해), 기본 프로필을 다시 복사 하 여 모든 항목을 다시 구성 하는 것은 재발을 디버그 하기가 어려울 가능성이 높습니다.

이러한 변경 내용은 고객이 업그레이드에 대 한 이유를 제공 하는 중요 한 변경 내용을 적용할 수 있는 분기가 있을 때까지 선반에 다시 배치 해야 합니다. 이러한 분기가 현재 존재 하지 않습니다. 미래의 반복 계획 회의에서 ' 너무 중단 ' 된 변경 내용/문제 집합을 검토 하 여 중요 한 질량에 도달 하 여 한 번에 하나의 변경 내용 집합을 실행 하는 것이 적절 한지 확인 합니다. 제한 된 엔지니어링 리소스로 인해 성실이 수행 되는 것이 아니라 "모두 허용 됩니다." 분기를 실행 하는 것은 위험 하며,이를 통해 테스트 및 유효성 검사를 분할 해야 합니다. 존재 하는 경우 해당 분기의 명확한 목적과 종료 날짜가 필요 합니다.

## <a name="long-term-management-of-breaking-changes"></a>주요 변경 내용에 대 한 장기적인 관리

장기적으로는 [목록 B](#list-b)에서 조건 집합을 늘려서 주요 변경 내용에 대 한 범위를 줄여야 합니다. [목록 A](#list-a) 의 항목 집합을 앞으로 이동 하면 "공용 API surface"에 있는 것으로 간주 되는 파일 및 자산의 집합에 대해 항상 기술적으로 중단 됩니다. 반복에 대해 약간 더 자유롭게 (즉, 내부 구현 세부 정보를 변경 하 고, 여러 클래스 간에 코드를 쉽게 리팩터링 하 고 공유할 수 있도록 하는 방법) 구현 세부 정보가 아니라 공식 화면에서 코드 부분을 보다 명확 하 게 파악할 수 있습니다.

이미 수행 된 작업 중 하나는 "실험적" 기능의 개념을 소개 하는 것입니다 .이 기능은 실험적 네임 스페이스에 속하고 테스트/설명서는 없으며, 공개적으로 존재 하도록 요청 되었지만 경고 없이 제거 및 업데이트 될 수 있습니다. 이로 인해 새 기능을 더 빨리 추가하여 이전 피드백을 받을 수 있지만 API 표면을 완전히 파악하지 않았을 수 있으므로 해당 API 표면과 즉시 연결되지는 않습니다.

### <a name="other-examples-of-things-that-could-help-in-the-future"></a>나중에 도움이 될 수 있는 기타 예제

- [내부 키워드](/dotnet/csharp/language-reference/keywords/internal)의 사용법입니다.
  이렇게 하면 외부 소비자에게 공개하지 않고도 자체 어셈블리 내에서 공유 코드를 가질 수 있습니다(코드 중복을 줄이기 위해).
- "내부" 네임스페이스 만들기(예: Microsoft.MixedReality.Toolkit.Internal.Utilities) 여기서 해당 내부 네임스페이스 내에 포함된 모든 항목은 언제든지 변경될 수 있으며 제거될 수 있음을 공개적으로 문서화합니다. 이는 C++ 헤더 라이브러리가 ::internal 네임스페이스를 사용하여 구현 세부 정보를 숨기는 방법과 비슷합니다.