---
title: 손 메뉴
description: MRTK의 손 모양 메뉴 예제 장면
author: cre8ivepark
ms.author: dongpark
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, 혼합 현실, 개발, mrtk, 수동 메뉴,
ms.openlocfilehash: 9bb0276c048912b4f463dd93d3303c9a3af8fe29
ms.sourcegitcommit: f338b1f121a10577bcce08a174e462cdc86d5874
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/01/2021
ms.locfileid: "113177524"
---
# <a name="hand-menu"></a><span data-ttu-id="fda50-104">손 메뉴</span><span class="sxs-lookup"><span data-stu-id="fda50-104">Hand menu</span></span>

![손 메뉴 UX 예제](../images/solver/MRTK_UX_HandMenu.png)

<span data-ttu-id="fda50-106">사용자는 직접 메뉴를 사용 하 여 자주 사용 하는 함수에 대 한 직접 연결 된 UI를 빠르게 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-106">Hand menus allow users to quickly bring up hand-attached UI for frequently used functions.</span></span> <span data-ttu-id="fda50-107">다른 개체와 상호 작용 하는 동안 거짓 활성화를 방지 하기 위해 손 모양 메뉴에는 ' 평면 필요 ' 및 ' 응시 활성화 사용 '과 같은 옵션이 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-107">To prevent false activation while interacting with other objects, hand menu provides options such as 'Require Flat Hand' and 'Use Gaze Activation'.</span></span> <span data-ttu-id="fda50-108">이러한 옵션을 사용 하 여 원치 않는 활성화를 방지 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-108">It is recommended to use these options to prevent unwanted activation.</span></span>

## <a name="hand-menu-examples"></a><span data-ttu-id="fda50-109">손 모양 메뉴 예제</span><span class="sxs-lookup"><span data-stu-id="fda50-109">Hand menu examples</span></span>

<span data-ttu-id="fda50-110">**수동 Menu예제. unity** 장면이 폴더 아래에 있습니다. ``MRTK/Examples/Demos/HandTracking/Scenes``</span><span class="sxs-lookup"><span data-stu-id="fda50-110">**HandMenuExamples.unity** scene is under ``MRTK/Examples/Demos/HandTracking/Scenes`` folder.</span></span> <span data-ttu-id="fda50-111">실행 되는 동안에는 현재 선택한 메뉴 유형만 활성화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-111">When it is running, the scene will only activate currently selected menu type.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_ExampleScene.png" width="600px" alt="HandMenu_ExampleScene">

<span data-ttu-id="fda50-112">폴더 아래에서 prefabs 메뉴를 찾을 수 있습니다 ``MRTK/Examples/Demos/HandTracking/Prefabs`` .</span><span class="sxs-lookup"><span data-stu-id="fda50-112">You can find these hand menu prefabs under ``MRTK/Examples/Demos/HandTracking/Prefabs`` folder.</span></span>

### <a name="handmenu_small_hideonhanddrop-and-handmenu_medium_hideonhanddrop"></a><span data-ttu-id="fda50-113">HandMenu_Small_HideOnHandDrop 및 HandMenu_Medium_HideOnHandDrop</span><span class="sxs-lookup"><span data-stu-id="fda50-113">HandMenu_Small_HideOnHandDrop and HandMenu_Medium_HideOnHandDrop</span></span>

<span data-ttu-id="fda50-114">이러한 두 예제에서는 **OnFirstHandDetected ()** 및 **OnLastHandLost ()** 이벤트에서 메뉴를 표시 하 고 숨기는 메뉴를 활성화 하 고 비활성화 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-114">These two examples simply activate and deactivate the MenuContent object to show and hide menu on **OnFirstHandDetected()** and **OnLastHandLost()** event.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example1.png" width="600" alt="HandMenu_ExampleScene 1">
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example2.png" width="600" alt="HandMenu_ExampleScene 2">

### <a name="handmenu_large_worldlock_on_grabandpull"></a><span data-ttu-id="fda50-115">HandMenu_Large_WorldLock_On_GrabAndPull</span><span class="sxs-lookup"><span data-stu-id="fda50-115">HandMenu_Large_WorldLock_On_GrabAndPull</span></span>

<span data-ttu-id="fda50-116">더 긴 상호 작용 시간이 필요한 복잡 한 메뉴의 경우 메뉴를 세계에서 잠그는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-116">For more complex menus that require longer interaction time, it is recommended to world-lock the menu.</span></span> <span data-ttu-id="fda50-117">이 예제에서 사용자는 **OnFirstHandDetected ()** 및 **OnLastHandLost ()** 이벤트에서 menucontent를 활성화 및 비활성화 하는 것 외에도 메뉴를 잡아 잠글 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-117">In this example, the user can grab and pull to world-lock the menu, in addition to activating and deactivating the MenuContent on **OnFirstHandDetected()** and **OnLastHandLost()** events.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example3.png" width="600" alt="HandMenu_ExampleScene 3">

<span data-ttu-id="fda50-118">배경 판을 `ManipulationHandler` 사용 하면 grabbable 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-118">Backplate's `ManipulationHandler` makes it grabbable and movable.</span></span> <span data-ttu-id="fda50-119">**조작 시작 이벤트에서** **SolverHandler. UpdateSolvers** 는 메뉴를 세계에서 잠그기 위해 비활성화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-119">**On Manipulation Started** event, **SolverHandler.UpdateSolvers** is deactivated to world-lock the menu.</span></span> <span data-ttu-id="fda50-120">또한 사용자가 작업이 완료 되 면 메뉴를 닫을 수 있는 **닫기 단추** 를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-120">Additionally, it shows the **Close button** to allow the user to close the menu when the task is finished.</span></span> <span data-ttu-id="fda50-121">**조작 종료 시** 이벤트는 HandConstraintPalmUp를 호출 하 여 사용자가 야자나무를 올리고 확인 하 여 메뉴를 다시 사용할 수 있도록 합니다 **.**</span><span class="sxs-lookup"><span data-stu-id="fda50-121">**On Manipulation Ended** event, it calls **HandConstraintPalmUp.StartWorldLockReattachCheckCoroutine** to allow the user bring the menu back to hand by raising and looking at the palm.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example4.png" width="600" alt="HandMenu_ExampleScene 4">

<span data-ttu-id="fda50-122">**닫기** 단추가 **SolverHandler. UpdateSolvers** 를 다시 활성화 하 고 **menucontent** 를 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-122">**Close** button reactivates **SolverHandler.UpdateSolvers** and hide the **MenuContent**.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example5.png" alt="HandMenu_ExampleScene 5">

### <a name="handmenu_large_autoworldlock_on_handdrop"></a><span data-ttu-id="fda50-123">HandMenu_Large_AutoWorldLock_On_HandDrop</span><span class="sxs-lookup"><span data-stu-id="fda50-123">HandMenu_Large_AutoWorldLock_On_HandDrop</span></span>

<span data-ttu-id="fda50-124">이 예는 HandMenu_Large_WorldLock_On_GrabAndPull와 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-124">This example is similar to HandMenu_Large_WorldLock_On_GrabAndPull.</span></span> <span data-ttu-id="fda50-125">유일한 차이점은 메뉴가 자동으로 삭제 될 때 자동으로 잠겨 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-125">The only difference is that the menu will be automatically world-locked on hand drop.</span></span> <span data-ttu-id="fda50-126">이 작업은 **OnLastHandLost ()** 이벤트에서 menucontent를 숨기지 않는 방법으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-126">This is done by simply not hiding the MenuContent on **OnLastHandLost()** event.</span></span> <span data-ttu-id="fda50-127">& 가져오기 동작은 HandMenu_Large_WorldLock_On_GrabAndPull 예제와 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-127">Grab & pull behavior is same as HandMenu_Large_WorldLock_On_GrabAndPull example.</span></span>

## <a name="scripts"></a><span data-ttu-id="fda50-128">스크립트</span><span class="sxs-lookup"><span data-stu-id="fda50-128">Scripts</span></span>

<span data-ttu-id="fda50-129">이 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 동작은 직접 UI, 메뉴 등의 직접 제한 된 콘텐츠에 대해 추적 된 개체를 안전한 지역으로 제한 하는 해를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-129">The [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc).</span></span> <span data-ttu-id="fda50-130">금고 지역은 손으로 교차 하지 않는 영역으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-130">Safe regions are considered areas that don't intersect with the hand.</span></span> <span data-ttu-id="fda50-131">또한 호출 된의 파생 클래스는 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) palm이 사용자를 향한 경우에는 해 찾기 추적 된 개체를 활성화 하는 일반적인 동작을 보여 주기 위해 포함 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-131">A derived class of [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) called [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</span></span>

<span data-ttu-id="fda50-132">추가 설명서는 각 속성에 사용할 수 있는 도구 설명을 참조 하십시오 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) .</span><span class="sxs-lookup"><span data-stu-id="fda50-132">Please see the tool tips available for each [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) property for additional documentation.</span></span> <span data-ttu-id="fda50-133">몇 가지 속성은 아래에 자세히 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-133">A few properties are defined in more detail below.</span></span>

<img src="../images/solver/MRTK_Solver_HandConstraintPalmUp.png" width="450" alt="HandMenu_ExampleScene Palm up">

* <span data-ttu-id="fda50-134">**금고 영역**: 안전한 영역에서 콘텐츠를 제한할 위치를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-134">**Safe Zone**: The safe zone specifies where on the hand to constrain content.</span></span> <span data-ttu-id="fda50-135">손으로와 개선 된 상호 작용 품질과 겹치지 않도록 콘텐츠를 Ulnar 측면에 배치 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-135">It is recommended that content be placed on the Ulnar Side to avoid overlap with the hand and improved interaction quality.</span></span> <span data-ttu-id="fda50-136">금고 영역은 카메라 보기와 직교 하 고 바늘의 경계 상자에 대 한 raycasting의 평면으로 투영 된 중심을 계산 하 여 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-136">Safe zones are calculated by taking the hands orientation projected into a plane orthogonal to the camera's view and raycasting against a bounding box around the hands.</span></span> <span data-ttu-id="fda50-137">금고 영역은에서 사용 하도록 정의 되어 [`IMixedRealityHand`](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) 있지만 다른 컨트롤러 형식 에서도 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-137">Safe zones are defined to work with [`IMixedRealityHand`](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) but also works with other controller types.</span></span> <span data-ttu-id="fda50-138">각 안전 영역이 여러 컨트롤러 유형에 서 무엇을 나타내는지 살펴보는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-138">It is recommended to explore what each safe zone represents on different controller types.</span></span>

* <span data-ttu-id="fda50-139">**카메라를 연결 하기 전까지 팔 로우** 이 활성 상태에서 [찾기]는 메뉴가 카메라를 향하도록 하는 응시와 충분히 나란히 정렬 될 때까지 회전을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-139">**Follow Hand Until Facing Camera** With this active, solver will follow hand rotation until the menu is sufficiently aligned with the gaze, at which point it faces the camera.</span></span> <span data-ttu-id="fda50-140">이는 SolverRotationBehavior에서 HandConstraintSolver의 LookAtTrackedObject를 LookAtMainCamera으로 변경 하는 방식으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-140">This works by changing the SolverRotationBehavior in the HandConstraintSolver, from LookAtTrackedObject to LookAtMainCamera as the GazeAlignment angle with the solver varies.</span></span>

<img src="../images/solver/MRTK_Solver_HandConstraintSafeZones.png" width="450" alt="HandMenu Safe Zones">

* <span data-ttu-id="fda50-141">**활성화 이벤트**: 현재는 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 4 개의 활성화 이벤트를 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-141">**Activation Events**: Currently the [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) triggers four activation events.</span></span> <span data-ttu-id="fda50-142">이러한 이벤트는 다양 한 조합으로 사용 하 여 고유한 동작을 만들 수 있습니다 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) `MRTK/Examples/Demos/HandTracking/Scenes/` . 이러한 동작에 대 한 예제는의 HandBasedMenuExample 장면을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="fda50-142">These events can be used in many different combinations to create unique [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behaviors, please see the HandBasedMenuExample scene under `MRTK/Examples/Demos/HandTracking/Scenes/` for examples of these behaviors.</span></span>

  * <span data-ttu-id="fda50-143">*On핸드 활성화*:가 IsHandActive 메서드를 만족 하는 경우 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-143">*OnHandActivate*: triggers when a hand satisfies the IsHandActive method.</span></span>
  * <span data-ttu-id="fda50-144">*On핸드 비활성화*: IsHandActive 메서드가 더 이상 충족 되지 않을 때 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-144">*OnHandDeactivate*: triggers when the IsHandActive method is no longer satisfied.</span></span>
  * <span data-ttu-id="fda50-145">*OnFirstHandDetected*: 손 모양 추적 상태가 뷰에서 손을 볼 때 뷰에서 첫 번째 손 모양으로 변경 되 면 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-145">*OnFirstHandDetected*: occurs when the hand tracking state changes from no hands in view, to the first hand in view.</span></span>
  * <span data-ttu-id="fda50-146">*OnLastHandLost*: 직접 추적 상태가 뷰에서 손을 볼 수 없도록 변경 될 때 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-146">*OnLastHandLost*: occurs when the hand tracking state changes from at least one hand in view, to no hands in view.</span></span>

* <span data-ttu-id="fda50-147">**해 찾기 활성화/비활성화 논리**: 현재 논리 활성화 및 비활성화에 대 한 권장 사항은 개체를 사용 [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) 하지 않도록 설정 하거나 사용 하지 않고 SolverHandler의 UpdateSolver 값을 사용 하 여 수행 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-147">**Solver Activation/Deactivation Logic**: Currently the recommendation for activating and deactivating [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) logic is to do so through the use of the SolverHandler's UpdateSolver value, rather than by disabling/enabling the object.</span></span> <span data-ttu-id="fda50-148">이는 연결 된 메뉴의 ManipulationHandler "OnManipulationStarted/종료" 이벤트 후에 트리거되는 편집기 기반 후크를 통해 예제 장면에서 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-148">This can be seen in the example scene through the editor-based hooks triggered after the attached menu's ManipulationHandler "OnManipulationStarted/Ended" events.</span></span>

  * <span data-ttu-id="fda50-149">*직접 제약 조건 논리 중지: 수동 제약 조건* 개체를 중지 (활성화/비활성화 논리를 실행 하지 않음) 하도록 설정 하는 경우 HandConstraintPalmUp을 비활성화 하는 대신 UpdateSolver를 False로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-149">*Stopping the hand-constraint logic*: When trying to set the hand constrained object to stop (as well as not run the activation/deactivation logic), set UpdateSolver to False rather than disabling HandConstraintPalmUp.</span></span>
    * <span data-ttu-id="fda50-150">응시 기반 (또는 비-응시 기반)을 다시 연결 하는 논리를 사용 하도록 설정 하려면이 다음에 HandConstraintPalmUp () 함수를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-150">If you want to enable the gaze-based (or even non-gaze-based) Reattach logic, this is then followed by calling the HandConstraintPalmUp.StartWorldLockReattachCheckCoroutine() function.</span></span> <span data-ttu-id="fda50-151">그러면 계속 해 서 "Is코 루틴 Controller" 조건이 충족 되는지 확인 하 고 UpdateSolver를 True로 설정 (또는 개체가 비활성화 된 경우) 하는 것을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-151">This will trigger a coroutine that then continues to check if the "IsValidController" criteria is met and will set UpdateSolver to True once it is (or the object is disabled)</span></span>
  * <span data-ttu-id="fda50-152">*직접 제약 조건 논리 시작*: 활성화 조건을 충족 하는지 여부에 따라 직접 제약 조건 개체를 다시 시작 하도록 설정 하려는 경우 SolverHandler의 UpdateSolver을 true로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-152">*Starting the hand-constraint logic*: When trying to set the hand constrained object to start following your hand again (based on whether it meets the activation criteria), set the SolverHandler's UpdateSolver to true.</span></span>

* <span data-ttu-id="fda50-153">**논리** 다시 연결: 현재 [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) SolverHandler의 UpdateSolver이 True 인지 여부에 관계 없이에서 대상 개체를 추적 된 지점에 자동으로 다시 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="fda50-153">**Reattach Logic**: Currently the [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is able to automatically reattach the target object to the tracked point, regardless of whether the SolverHandler's UpdateSolver is True or not.</span></span> <span data-ttu-id="fda50-154">이는 HandConstraintPalmUp의 StartWorldLockReattachCheckCoroutine () 함수를 호출 하 여 수행 됩니다 .이 함수는 세계에서 잠긴 후 (이 경우 실제로 SolverHandler의 UpdateSolver을 False로 설정 합니다.)</span><span class="sxs-lookup"><span data-stu-id="fda50-154">This is done through calling the HandConstraintPalmUp's StartWorldLockReattachCheckCoroutine() function, after it's been world-locked (which in this case, is effectively setting the SolverHandler's UpdateSolver to False).</span></span>

## <a name="see-also"></a><span data-ttu-id="fda50-155">참조</span><span class="sxs-lookup"><span data-stu-id="fda50-155">See also</span></span>

* [<span data-ttu-id="fda50-156">Button</span><span class="sxs-lookup"><span data-stu-id="fda50-156">Button</span></span>](button.md)
* [<span data-ttu-id="fda50-157">메뉴 근처</span><span class="sxs-lookup"><span data-stu-id="fda50-157">Near Menu</span></span>](near-menu.md)
