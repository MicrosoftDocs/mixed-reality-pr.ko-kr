---
title: 솔버 개요
description: MRTK의 솔버 개요
author: CDiaz-MS
ms.author: cadia
ms.date: 01/12/2021
ms.localizationpriority: high
keywords: Unity ,HoloLens, HoloLens 2, Mixed Reality, 개발, MRTK, 솔버,
ms.openlocfilehash: bf9bbfe578ace576fca8870f038f145037a6838d
ms.sourcegitcommit: f338b1f121a10577bcce08a174e462cdc86d5874
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/01/2021
ms.locfileid: "113176455"
---
# <a name="solver-overview"></a><span data-ttu-id="efb77-104">솔버 개요</span><span class="sxs-lookup"><span data-stu-id="efb77-104">Solver overview</span></span>

![솔버 기본](../../images/solver/MRTK_Solver_Main.png)

<span data-ttu-id="efb77-106">솔버는 미리 정의된 알고리즘에 따라 개체의 위치 및 방향을 계산하는 방법을 용이하게 하는 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-106">Solvers are components that facilitate the means of calculating an object's position & orientation according to a predefined algorithm.</span></span> <span data-ttu-id="efb77-107">예를 들어 사용자의 시선 응시 광선 투사가 현재 비추는 중인 표면에 개체를 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-107">An example may be placing an object on the surface the user's gaze raycast currently hits.</span></span>

<span data-ttu-id="efb77-108">또한, 구성 요소에 대한 업데이트 순서를 Unity에 지정할 수 있는 안정적인 방법이 없으므로 솔버 시스템은 이러한 변환 계산에 대한 작업 순서를 명확하게 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-108">Furthermore, the Solver system deterministically defines an order of operations for these transform calculations as there is no reliable way to specify to Unity the update order for components.</span></span>

<span data-ttu-id="efb77-109">솔버는 다른 개체나 시스템에 개체를 연결하는 다양한 동작을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-109">Solvers offer a range of behaviors to attach objects to other objects or systems.</span></span> <span data-ttu-id="efb77-110">다른 한가지 예는 카메라에 따라 사용자의 앞에 있는 태그얼롱 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-110">One other example would be a tag-along object that hovers in front of the user (based on the camera).</span></span> <span data-ttu-id="efb77-111">솔버를 컨트롤러 및 개체에 연결하여 개체가 컨트롤러를 태그얼롱하도록 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-111">A solver could also be attached to a controller and an object to make the object tag-along the controller.</span></span> <span data-ttu-id="efb77-112">모든 솔버를 안전하게 누적시킬 수 있습니다(예: 태그얼롱 동작 + 표면 자성 + 탄력).</span><span class="sxs-lookup"><span data-stu-id="efb77-112">All solvers can be safely stacked, for example a tag-along behavior + surface magnetism + momentum.</span></span>

## <a name="how-to-use-a-solver"></a><span data-ttu-id="efb77-113">솔버를 사용하는 방법</span><span class="sxs-lookup"><span data-stu-id="efb77-113">How to use a solver</span></span>

<span data-ttu-id="efb77-114">솔버 시스템은 세 가지 범주의 스크립트로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-114">The Solver system consists of three categories of scripts:</span></span>

* <span data-ttu-id="efb77-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): 모든 솔버가 파생되는 기본 추상 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): The base abstract class that all solvers derive from.</span></span> <span data-ttu-id="efb77-116">상태 추적, 매개 변수 및 구현 다듬기, 자동 솔버 시스템 통합 및 업데이트 순서를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-116">It provides state tracking, smoothing parameters and implementation, automatic solver system integration, and update order.</span></span>
* <span data-ttu-id="efb77-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): 추적할 참조 개체를 설정하고(예: 기본 카메라 변환, 손 광선 등) 솔버 구성 요소 수집을 처리하고 적절한 순서로 업데이트를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): Sets the reference object to track against (ex: the main camera transform, hand ray, etc.), handles gathering of solver components, and executes updating them in the proper order.</span></span>

<span data-ttu-id="efb77-118">세 번째 범주는 솔버 자체입니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-118">The third category is the solver itself.</span></span> <span data-ttu-id="efb77-119">다음 솔버는 기본 동작에 대한 구성 요소를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-119">The following solvers provide the building blocks for basic behavior:</span></span>

* <span data-ttu-id="efb77-120">[`Orbital`](#orbital): 참조된 개체에서 지정된 위치 및 오프셋으로 잠급니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-120">[`Orbital`](#orbital): Locks to a specified position and offset from the referenced object.</span></span>
* <span data-ttu-id="efb77-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): 참조된 개체의 보기와 관련된 일정한 크기를 유지하도록 크기를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): Scales to maintain a constant size relative to the view of the referenced object.</span></span>
* <span data-ttu-id="efb77-122">[`RadialView`](#radialview): 참조된 개체가 캐스팅하는 보기 콘 내에 개체를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-122">[`RadialView`](#radialview): Keeps the object within a view cone cast by the referenced object.</span></span>
* <span data-ttu-id="efb77-123">[`Follow`](#follow): 참조된 개체의 사용자 정의 경계 집합 내에 개체를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-123">[`Follow`](#follow): Keeps the object within a set of user defined bounds of the referenced object.</span></span>
* <span data-ttu-id="efb77-124">[`InBetween`](#inbetween): 추적된 두 개체 사이에 개체를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-124">[`InBetween`](#inbetween): Keeps an object in between two tracked objects.</span></span>
* <span data-ttu-id="efb77-125">[`SurfaceMagnetism`](#surfacemagnetism): 세계의 표면에 광선을 투사하고 개체를 해당 표면에 정렬합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-125">[`SurfaceMagnetism`](#surfacemagnetism): casts rays to surfaces in the world, and align the object to that surface.</span></span>
* <span data-ttu-id="efb77-126">[`DirectionalIndicator`](#directionalindicator): 방향 표시기로 개체의 위치와 방향을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-126">[`DirectionalIndicator`](#directionalindicator): Determines the position and orientation of an object as a directional indicator.</span></span> <span data-ttu-id="efb77-127">SolverHandler 추적 대상의 참조 지점에서 이 표시기는 제공된 DirectionalTarget 방향으로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-127">From the point of reference of the SolverHandler Tracked Target, this indicator will orient towards the DirectionalTarget supplied.</span></span>
* <span data-ttu-id="efb77-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): 가속/속도/마찰을 적용하여 다른 솔버/구성 요소에 의해 이동되는 개체의 탄력과 탄성을 시뮬레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): Applies acceleration/velocity/friction to simulate momentum and springiness for an object being moved by other solvers/components.</span></span>
* <span data-ttu-id="efb77-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): GameObject와 손이 교차하지 않는 영역에서 손을 따르도록 개체를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Constrains object to follow hands in a region that doesn't intersect the GameObject with the hands.</span></span> <span data-ttu-id="efb77-130">메뉴 등과 같이 손이 제한된 대화형 콘텐츠에 유용합니다. 이 솔버는 [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand)와 함께 작동하지만 [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController)에서도 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-130">Useful for hand constrained interactive content such as menus, etc. This solver is intended to work with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) but also works with [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span></span>
* <span data-ttu-id="efb77-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): HandConstraint에서 파생되지만 활성화 전에 손바닥이 사용자를 향하고 있는지 테스트하는 로직이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Derives from HandConstraint but includes logic to test if the palm is facing the user before activation.</span></span> <span data-ttu-id="efb77-132">이 솔버는 [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) 컨트롤러에서만 작동하며 다른 컨트롤러 유형에서는 이 솔버가 기본 클래스처럼 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-132">This solver only works with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) controllers, with other controller types this solver will behave just like its base class.</span></span>

<span data-ttu-id="efb77-133">솔버 시스템을 사용하기 위해 위에 나열된 구성 요소 중 하나를 GameObject에 추가하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-133">In order to use the Solver system, simply add one of the components listed above to a GameObject.</span></span> <span data-ttu-id="efb77-134">모든 솔버에는 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler)가 필요하므로 Unity에서 자동으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-134">Since all Solvers require a [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), one will be created automatically by Unity.</span></span>

> [!NOTE]
> <span data-ttu-id="efb77-135">솔버 시스템 사용 방법의 예는 **SolverExamples.scene** 파일에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-135">Examples of how to use the Solvers system can be found in the **SolverExamples.scene** file.</span></span>

## <a name="how-to-change-tracking-reference"></a><span data-ttu-id="efb77-136">추적 참조를 변경하는 방법</span><span class="sxs-lookup"><span data-stu-id="efb77-136">How to change tracking reference</span></span>

<span data-ttu-id="efb77-137">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) 구성 요소의 *Tracked Target Type*(추적 대상 유형) 속성은 모든 솔버가 알고리즘을 계산하는 데 사용할 참조 지점을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-137">The *Tracked Target Type* property of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component defines the point of reference all solvers will use to calculate their algorithms.</span></span> <span data-ttu-id="efb77-138">예를 들어 단순한 [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) 구성 요소가 있는 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head)의 값 유형은 어떤 표면에 비추는지를 해결하기 위해 사용자의 시선 응시 방향으로 헤드에서 광선 투사를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-138">For example, a value type of [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) with a simple [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component will result in a raycast from the head and in the direction of the user's gaze for solving what surface is hit.</span></span> <span data-ttu-id="efb77-139">`TrackedTargetType` 속성의 잠재적 값은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-139">Potential values for the `TrackedTargetType` property are:</span></span>

* <span data-ttu-id="efb77-140">*Head*: 참조 지점이 기본 카메라의 변환입니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-140">*Head* : Point of reference is the transform of the main camera</span></span>
* <span data-ttu-id="efb77-141">*ControllerRay*: 참조 지점이 선 광선의 방향을 가리키는 컨트롤러의 [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) 변환입니다(예:</span><span class="sxs-lookup"><span data-stu-id="efb77-141">*ControllerRay*: Point of reference is the [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) transform on a controller (i.e</span></span> <span data-ttu-id="efb77-142">모션 컨트롤러 또는 핸드 컨트롤러의 포인터 원점).</span><span class="sxs-lookup"><span data-stu-id="efb77-142">pointer origin on a motion controller or hand controller) pointing in the direction of the line ray</span></span>
  * <span data-ttu-id="efb77-143">`TrackedHandedness` 속성을 사용하여 사용하는 손 기본 설정을 선택합니다(예:</span><span class="sxs-lookup"><span data-stu-id="efb77-143">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="efb77-144">왼쪽, 오른쪽, 둘 다).</span><span class="sxs-lookup"><span data-stu-id="efb77-144">Left, Right, Both)</span></span>
* <span data-ttu-id="efb77-145">*HandJoint*: 참조 지점이 특정 손 관절의 변환입니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-145">*HandJoint*: Point of reference is the transform of a specific hand joint</span></span>
  * <span data-ttu-id="efb77-146">`TrackedHandedness` 속성을 사용하여 사용하는 손 기본 설정을 선택합니다(예:</span><span class="sxs-lookup"><span data-stu-id="efb77-146">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="efb77-147">왼쪽, 오른쪽, 둘 다).</span><span class="sxs-lookup"><span data-stu-id="efb77-147">Left, Right, Both)</span></span>
  * <span data-ttu-id="efb77-148">`TrackedHandJoint` 속성을 사용하여 활용할 관절 변환을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-148">Use the  `TrackedHandJoint` property to determine the joint transform to utilize</span></span>
* <span data-ttu-id="efb77-149">*CustomOverride*: 지정된 `TransformOverride`의 참조 지점입니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-149">*CustomOverride*: Point of reference from the assigned `TransformOverride`</span></span>

> [!NOTE]
> <span data-ttu-id="efb77-150">*ControllerRay* 및 *HandJoint* 유형 모두에 대해 솔버 처리기는 먼저 왼쪽 컨트롤러/손 변환을 제공한 다음 전자를 사용할 수 없거나 `TrackedHandedness` 속성이 달리 지정하지 않은 경우 오른쪽을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-150">For both *ControllerRay* and *HandJoint* types, the solver handler will attempt to provide the left controller/hand transform first and then the right if the former is not available or unless the `TrackedHandedness` property specifies otherwise.</span></span>

<span data-ttu-id="efb77-151">![솔버가 추적한 개체](../../images/solver/TrackedObjectType-Example.gif) 
*각 TrackedTargetType과 관련된 다양한 속성의 예*</span><span class="sxs-lookup"><span data-stu-id="efb77-151">![Solver Tracked Object](../../images/solver/TrackedObjectType-Example.gif) 
*Example of various properties associated with each TrackedTargetType*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="efb77-152">대부분의 솔버는 `SolverHandler`에서 제공하는 추적된 변환 대상의 앞으로 벡터를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-152">Most solvers use the forward vector of the tracked transform target supplied by the `SolverHandler`.</span></span> <span data-ttu-id="efb77-153">*손 관절* 추적 대상 유형을 사용하는 경우 손바닥 관절의 전방 벡터가 손바닥이 아닌 손가락을 가리킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-153">When using a *Hand Joint* tracked target type, the forward vector of the palm joint may point through the fingers and not through the palm.</span></span> <span data-ttu-id="efb77-154">이는 손 관절 데이터를 제공하는 플랫폼에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-154">This depends on the platform supplying the hand joint data.</span></span> <span data-ttu-id="efb77-155">입력 시뮬레이션 및 Windows Mixed Reality의 경우 손바닥을 통해 위로 향하는 *위 벡터* 입니다(예:</span><span class="sxs-lookup"><span data-stu-id="efb77-155">For input simulation and Windows Mixed Reality, it is the *up vector* that points up through the palm (i.e</span></span> <span data-ttu-id="efb77-156">녹색 벡터는 위로, 파란색 벡터는 앞으로).</span><span class="sxs-lookup"><span data-stu-id="efb77-156">green vector is up, blue vector is forward).</span></span>
>
> ![앞으로 위로 벡터](../../images/solver/HandJoint_ForwardUpVectors.png)
>
> <span data-ttu-id="efb77-158">이를 극복하려면 `SolverHandler`의 *추가 회전* 속성을 **<90, 0, 0>** 으로 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-158">To overcome this, update the *Additional Rotation* property on the `SolverHandler` to **<90, 0, 0>**.</span></span> <span data-ttu-id="efb77-159">이렇게 하면 솔버에 제공된 앞으로 벡터가 손바닥을 통해 손에서 바깥쪽으로 향하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-159">This will ensure the forward vector supplied to solvers is pointing through the palm and outward away from the hand.</span></span>
>
> ![추가 회전](../../images/solver/SolverHandler_AdditionalRotation.png)
>
> <span data-ttu-id="efb77-161">또는 *컨트롤러 광선* 추적 대상 유형을 사용하여 손으로 가리키는 유사한 동작을 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-161">Alternatively, use the *Controller Ray* tracked target type to get similar behavior for pointing with hands.</span></span>

## <a name="how-to-chain-solvers"></a><span data-ttu-id="efb77-162">솔버를 연결하는 방법</span><span class="sxs-lookup"><span data-stu-id="efb77-162">How to chain solvers</span></span>

<span data-ttu-id="efb77-163">동일한 GameObject에 여러 `Solver` 구성 요소를 추가하여 알고리즘을 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-163">It is possible to add multiple `Solver` components to the same GameObject thus chaining their algorithms.</span></span> <span data-ttu-id="efb77-164">`SolverHandler` 구성 요소는 동일한 GameObject의 모든 솔버 업데이트를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-164">The `SolverHandler` components handles updating all solvers on the same GameObject.</span></span> <span data-ttu-id="efb77-165">기본적으로 `SolverHandler`는 시작 시 `GetComponents<Solver>()`를 호출하여 검사기에 나타나는 순서대로 솔버를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-165">By default the `SolverHandler` calls `GetComponents<Solver>()` on Start which will return the Solvers in the order that they appear in the inspector.</span></span>

<span data-ttu-id="efb77-166">또한 *업데이트된 연결 변환* 속성을 true로 설정하면 해당 `Solver`에게 계산된 위치, 방향 및 배율을 모든 솔버가 액세스할 수 있는 중간 변수에 저장하라고 지시합니다(예:</span><span class="sxs-lookup"><span data-stu-id="efb77-166">Furthermore, setting the *Updated Linked Transform* property to true will instruct that `Solver` to save its calculated position, orientation, & scale to an intermediary variable accessible by all Solvers (i.e</span></span> <span data-ttu-id="efb77-167">`GoalPosition`).</span><span class="sxs-lookup"><span data-stu-id="efb77-167">`GoalPosition`).</span></span> <span data-ttu-id="efb77-168">false인 경우 `Solver`는 GameObject의 변환을 직접 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-168">When false, the `Solver` will update the GameObject's transform directly.</span></span> <span data-ttu-id="efb77-169">다른 솔버는 중간 위치에 변환 속성을 저장하여 중간 변수부터 계산을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-169">By saving the transform properties to an intermediary location, other Solvers are able to perform their calculations starting from the intermediary variable.</span></span> <span data-ttu-id="efb77-170">Unity가 gameObject.transform에 대한 업데이트가 동일한 프레임 내에서 누적되도록 허용하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-170">This is because Unity does not allow updates to gameObject.transform to stack within the same frame.</span></span>

> [!NOTE]
> <span data-ttu-id="efb77-171">개발자는 `SolverHandler.Solvers` 속성을 직접 설정하여 솔버의 실행 순서를 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-171">Developers can modify the order of execution of Solvers by setting the `SolverHandler.Solvers` property directly.</span></span>

## <a name="how-to-create-a-new-solver"></a><span data-ttu-id="efb77-172">새 솔버를 만드는 방법</span><span class="sxs-lookup"><span data-stu-id="efb77-172">How to create a new solver</span></span>

<span data-ttu-id="efb77-173">모든 솔버는 추상 기본 클래스 [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver)에서 상속해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-173">All solvers must inherit from the abstract base class, [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver).</span></span> <span data-ttu-id="efb77-174">솔버 확장의 기본 요구 사항에는 `SolverUpdate` 메서드 재정의가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-174">The primary requirements of a Solver extension involves overriding the `SolverUpdate` method.</span></span> <span data-ttu-id="efb77-175">이 메서드에서 개발자는 상속된 `GoalPosition`, `GoalRotation` 및 `GoalScale` 속성을 원하는 값으로 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-175">In this method, developers should update the inherited `GoalPosition`, `GoalRotation` and `GoalScale` properties to the desired values.</span></span> <span data-ttu-id="efb77-176">또한 일반적으로 소비자가 원하는 참조 프레임으로 `SolverHandler.TransformTarget`을 활용하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-176">Furthermore, it is generally valuable to leverage `SolverHandler.TransformTarget` as the frame of reference desired by the consumer.</span></span>

<span data-ttu-id="efb77-177">아래에 제공된 코드는 첨부된 개체를 `SolverHandler.TransformTarget`의 2m 앞에 배치하는 `InFront`라는 새 솔버 구성 요소의 예를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-177">The code provided below gives an example of a new Solver component called `InFront` that places the attached object 2m in front of the `SolverHandler.TransformTarget`.</span></span> <span data-ttu-id="efb77-178">소비자가 `SolverHandler.TrackedTargetType`을 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head)로 설정하면 `SolverHandler.TransformTarget`이 카메라 변환이 되므로 이 솔버는 프레임마다 사용자의 시선 응시의 2m 앞에 연결된 GameObject를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-178">If the `SolverHandler.TrackedTargetType` is set by the consumer as [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the `SolverHandler.TransformTarget` will be the camera transform and thus this Solver will place the attached GameObject 2m in front of the users' gaze every frame.</span></span>

```c#
/// <summary>
/// InFront solver positions an object 2m in front of the tracked transform target
/// </summary>
public class InFront : Solver
{
    ...

    public override void SolverUpdate()
    {
        if (SolverHandler != null && SolverHandler.TransformTarget != null)
        {
            var target = SolverHandler.TransformTarget;
            GoalPosition = target.position + target.forward * 2.0f;
        }
    }
}
```

## <a name="solver-implementation-guides"></a><span data-ttu-id="efb77-179">솔버 구현 가이드</span><span class="sxs-lookup"><span data-stu-id="efb77-179">Solver implementation guides</span></span>

### <a name="common-solver-properties"></a><span data-ttu-id="efb77-180">일반적인 솔버 속성</span><span class="sxs-lookup"><span data-stu-id="efb77-180">Common solver properties</span></span>

<span data-ttu-id="efb77-181">모든 솔버 구성 요소에는 코어 솔버 동작을 제어하는 동일한 속성의 코어 집합이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-181">Every Solver component has a core-set of identical properties that control the core Solver behavior.</span></span>

<span data-ttu-id="efb77-182">*다듬기* 가 사용하도록 설정된 경우 솔버는 시간이 지남에 따라 GameObject의 변환을 계산된 값으로 점진적으로 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-182">If *Smoothing* is enabled, then the Solver will gradually update the transform of the GameObject over time to the calculated values.</span></span> <span data-ttu-id="efb77-183">이 변경의 속도는 모든 변환 구성 요소의 *LerpTime* 속성에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-183">The speed of this change is determined by every transform component's *LerpTime* property.</span></span> <span data-ttu-id="efb77-184">예를 들어 *MoveLerpTime* 값이 높을수록 프레임 간의 이동 증가가 느려집니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-184">For example, a higher *MoveLerpTime* value will result in slower increments in movement between frames.</span></span>

<span data-ttu-id="efb77-185">*MaintainScale* 이 사용하도록 설정된 경우 솔버는 GameObject의 기본 로컬 배율을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-185">If *MaintainScale* is enabled, then the Solver will utilize the GameObject's default local scale.</span></span>

<span data-ttu-id="efb77-186">![코어 솔버 속성](../../images/solver/GeneralSolverProperties.png)</span><span class="sxs-lookup"><span data-stu-id="efb77-186">![Core Solver Properties](../../images/solver/GeneralSolverProperties.png)</span></span>  
<span data-ttu-id="efb77-187">*모든 솔버 구성 요소에서 상속되는 공통 속성*</span><span class="sxs-lookup"><span data-stu-id="efb77-187">*Common properties inherited by all Solver components*</span></span>

### <a name="orbital"></a><span data-ttu-id="efb77-188">궤도</span><span class="sxs-lookup"><span data-stu-id="efb77-188">Orbital</span></span>

<span data-ttu-id="efb77-189">[`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) 클래스는 태양계의 행성처럼 작동하는 태그얼롱 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-189">The [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) class is a tag-along component that behaves like planets in a solar system.</span></span> <span data-ttu-id="efb77-190">이 솔버는 연결된 GameObject가 추적된 변환 주위를 공전하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-190">This Solver will ensure the attached GameObject orbits around the tracked transform.</span></span> <span data-ttu-id="efb77-191">따라서 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler)의 *추적 대상 유형* 이 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head)로 설정되면 GameObject가 고정 오프셋이 적용되어 사용자의 헤드 주위를 공전합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-191">Thus, if the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the GameObject will orbit around the user's head with a fixed offset applied.</span></span>

<span data-ttu-id="efb77-192">개발자는 이 고정 오프셋을 수정하여 메뉴 또는 기타 장면 구성 요소를 사용자 주변의 눈 높이나 허리 높이 등으로 유지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-192">Developers can modify this fixed offset to keep menus or other scene components at eye-level or at waist level etc. around a user.</span></span> <span data-ttu-id="efb77-193">이는 *로컬 오프셋* 및 *월드 오프셋* 속성을 수정하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-193">This is done by modifying the *Local Offset* and *World Offset* properties.</span></span> <span data-ttu-id="efb77-194">*방향 유형* 속성은 개체가 원래 회전을 유지해야 하거나 항상 카메라를 향해야 하거나 위치를 제어하는 변환이 무엇이든 직면해야 하는 경우 개체에 적용되는 회전을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-194">The *Orientation Type* property determines the rotation applied to the object if it should maintain its original rotation or always face the camera or face whatever transform is driving its position etc.</span></span>

<span data-ttu-id="efb77-195">![궤도 예](../../images/solver/OrbitalExample.png)</span><span class="sxs-lookup"><span data-stu-id="efb77-195">![Orbital Example](../../images/solver/OrbitalExample.png)</span></span>  
<span data-ttu-id="efb77-196">*궤도 예*</span><span class="sxs-lookup"><span data-stu-id="efb77-196">*Orbital example*</span></span>

### <a name="radialview"></a><span data-ttu-id="efb77-197">RadialView</span><span class="sxs-lookup"><span data-stu-id="efb77-197">RadialView</span></span>

<span data-ttu-id="efb77-198">[`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView)는 사용자 보기의 절두체 내에 GameObject의 특정 부분을 유지하는 또 다른 태그얼롱 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-198">The [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is another tag-along component that keeps a particular portion of a GameObject within the frustum of the user's view.</span></span>

<span data-ttu-id="efb77-199">*최소 및 최대 보기 정도* 속성은 GameObject의 일부가 항상 보기에 있어야 하는 크기를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-199">The *Min & Max View Degrees* properties determines how large of a portion of the GameObject must always be in view.</span></span>

<span data-ttu-id="efb77-200">*최소 및 최대 거리* 속성은 GameObject가 사용자로부터 얼마나 멀리 떨어져 있어야 하는지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-200">The *Min & Max Distance* properties determines how far the GameObject should be kept from the user.</span></span> <span data-ttu-id="efb77-201">예를 들어 *최소 거리* 가 1m인 GameObject를 향해 걸어 가면 GameObject가 사용자에게 1m 이상 가까워지지 않도록 멀리 밀려납니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-201">For example, walking towards the GameObject with a *Min Distance* of 1m will push the GameObject away to ensure it is never closer than 1m to the user.</span></span>

<span data-ttu-id="efb77-202">일반적으로 [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView)는 구성 요소가 사용자의 시선을 따르도록 *추적된 대상 유형* 이 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head)로 설정된 것과 함께 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-202">Generally, the [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is used in conjunction with *Tracked Target Type* set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) so that the component follows the user's gaze.</span></span> <span data-ttu-id="efb77-203">그러나 이 구성 요소는 *추적된 대상 유형* 의 *"보기"* 에서 유지되도록 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-203">However, this component can function to be kept in *"view"* of any *Tracked Target Type*.</span></span>

<span data-ttu-id="efb77-204">![RadialView 예](../../images/solver/RadialViewExample.png)</span><span class="sxs-lookup"><span data-stu-id="efb77-204">![RadialView Example](../../images/solver/RadialViewExample.png)</span></span>  
<span data-ttu-id="efb77-205">*RadialView 예*</span><span class="sxs-lookup"><span data-stu-id="efb77-205">*RadialView example*</span></span>

### <a name="follow"></a><span data-ttu-id="efb77-206">팔로우</span><span class="sxs-lookup"><span data-stu-id="efb77-206">Follow</span></span>

<span data-ttu-id="efb77-207">[`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) 클래스는 로컬 전방 축을 기준으로 추적된 대상 앞에 요소를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-207">The [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) class positions an element in front of the of the tracked target relative to its local forward axis.</span></span> <span data-ttu-id="efb77-208">요소는 느슨하게 제한(즉, 태그얼롱)될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-208">The element can be loosely constrained (a.k.a.</span></span> <span data-ttu-id="efb77-209">따라서 추적 대상이 사용자 정의된 범위를 벗어나 이동할 때까지 따르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-209">tag-along) so that it doesn't follow until the tracked target moves beyond user defined bounds.</span></span>

<span data-ttu-id="efb77-210">RadialView 솔버와 유사하게 작동하며 *최대 수평 및 수직 뷰 각도* 를 관리하기 위한 추가 컨트롤과 개체의 *방향* 을 변경하는 메커니즘이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-210">It works similarly to the RadialView solver, with additional controls to manage *Max Horizontal & Vertical View Degrees*, and mechanisms to alter the *Orientation* of the object.</span></span>

<span data-ttu-id="efb77-211">![팔로우 속성](../../images/solver/FollowExample.png)</span><span class="sxs-lookup"><span data-stu-id="efb77-211">![Follow properties](../../images/solver/FollowExample.png)</span></span>  
<span data-ttu-id="efb77-212">*팔로우 속성*</span><span class="sxs-lookup"><span data-stu-id="efb77-212">*Follow properties*</span></span>

<span data-ttu-id="efb77-213">![팔로우 장면 예](../../images/solver/FollowExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="efb77-213">![Follow example scene](../../images/solver/FollowExampleScene.gif)</span></span>  
<span data-ttu-id="efb77-214">*팔로우 장면 예(Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="efb77-214">*Follow Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span></span>

### <a name="inbetween"></a><span data-ttu-id="efb77-215">InBetween</span><span class="sxs-lookup"><span data-stu-id="efb77-215">InBetween</span></span>

<span data-ttu-id="efb77-216">[`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) 클래스는 두 변환 사이에 연결된 GameObject를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-216">The [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) class will keep the attached GameObject between two transforms.</span></span> <span data-ttu-id="efb77-217">이 두 변환 엔드포인트는 GameObject의 자체 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *추적 대상 유형* 및 [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) 구성 요소의 *두 번째 추적 대상 유형* 속성에 의해 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-217">These two transform endpoints are defined by the GameObject's own [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *Tracked Target Type* and the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component's *Second Tracked Target Type* property.</span></span> <span data-ttu-id="efb77-218">일반적으로 두 유형 모두 [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride)로 설정되고 결과 `SolverHandler.TransformOverride` 및 `InBetween.SecondTransformOverride` 값은 두 개의 추적된 엔드포인트로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-218">Generally, both types will be set to [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) and the resulting `SolverHandler.TransformOverride` and `InBetween.SecondTransformOverride` values set to the two tracked endpoints.</span></span>

<span data-ttu-id="efb77-219">런타임 시 [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) 구성 요소는 *두 번째 추적 대상 유형* 및 *두 번째 변환 재정의* 속성을 기반으로 또 다른 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) 구성 요소를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-219">At runtime, the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component will create another [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component based on the *Second Tracked Target Type* and *Second Transform Override* properties.</span></span>

<span data-ttu-id="efb77-220">`PartwayOffset`은 두 변환 사이의 선을 따라 개체가 중간에 0.5, 첫 번째 변환에 1.0, 두 번째 변환에 0.0으로 배치될 위치를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-220">The `PartwayOffset` defines where along the line between two transforms the object shall be placed with 0.5 as halfway, 1.0 at the first transform, and 0.0 at the second transform.</span></span>

<span data-ttu-id="efb77-221">![InBetween 예](../../images/solver/InBetweenExample.png)</span><span class="sxs-lookup"><span data-stu-id="efb77-221">![InBetween Example](../../images/solver/InBetweenExample.png)</span></span>  
<span data-ttu-id="efb77-222">*InBetween 솔버를 사용하여 두 변환 사이에 개체를 유지하는 예*</span><span class="sxs-lookup"><span data-stu-id="efb77-222">*Example of using InBetween solver to keep object between two transforms*</span></span>

### <a name="surfacemagnetism"></a><span data-ttu-id="efb77-223">SurfaceMagnetism</span><span class="sxs-lookup"><span data-stu-id="efb77-223">SurfaceMagnetism</span></span>

<span data-ttu-id="efb77-224">[`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism)은 표면의 설정된 LayerMask에 대해 광선 투사를 수행하고 해당 접촉 지점에 GameObject를 배치하는 방식으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-224">The [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) works by performing a raycast against a set LayerMask of surfaces and placing the GameObject at that point of contact.</span></span>

<span data-ttu-id="efb77-225">*표면 법선 오프셋* 은 GameObject를 표면에 비추는 지점에서 표면으로부터 법선 방향으로 설정된 거리(미터 단위)에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-225">The *Surface Normal Offset* will place the GameObject a set distance in meters away from the surface in the direction of the normal at the hit point on the surface.</span></span>

<span data-ttu-id="efb77-226">반대로 *표면 광선 오프셋* 은 GameObject를 표면에서 미터 단위로 설정된 거리에 배치하지만 수행된 광선 투사의 반대 방향에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-226">Conversely, the *Surface Ray Offset* will place the GameObject a set distance in meters away from the surface but in the opposite direction of the raycast performed.</span></span> <span data-ttu-id="efb77-227">따라서 광선 투사가 사용자의 시선인 경우 GameObject는 표면에 비추는 지점에서 카메라까지 선을 따라 더 가깝게 이동됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-227">Thus, if the raycast is the user's gaze, then the GameObject will move closer along the line from the hit point on the surface to the camera.</span></span>

<span data-ttu-id="efb77-228">*방향 모드* 는 표면의 법선과 관련하여 적용할 회전 유형을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-228">The *Orientation Mode* determines the type of rotation to apply in relation to the normal on the surface.</span></span>

* <span data-ttu-id="efb77-229">*없음* - 회전이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-229">*None* - No rotation applied</span></span>
* <span data-ttu-id="efb77-230">*TrackedTarget* - 개체가 광선 투사를 구동하는 추적된 변환을 향합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-230">*TrackedTarget* - Object will face the tracked transform driving the raycast</span></span>
* <span data-ttu-id="efb77-231">*SurfaceNormal* - 개체가 표면에 비추는 지점에서 법선을 기준으로 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-231">*SurfaceNormal* - Object will align based on normal at hit point on surface</span></span>
* <span data-ttu-id="efb77-232">*Blended* - 개체가 표면에 비추는 지점에서 법선을 기준으로 정렬되고 추적된 변환을 향하는 것을 기준으로 정렬됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-232">*Blended* - Object will align based on normal at hit point on surface AND based on facing the tracked transform.</span></span>

<span data-ttu-id="efb77-233">연결된 GameObject가 *없음* 이외의 모드에서 수직으로 유지되도록 하려면 *방향을 세로로 유지* 를 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-233">To force the associated GameObject to stay vertical in any mode other than *None*, enable *Keep Orientation Vertical*.</span></span>

> [!NOTE]
> <span data-ttu-id="efb77-234">*방향 모드* 가 *혼합* 으로 설정된 경우 *방향 혼합* 속성을 사용하여 회전 계수 간의 균형을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-234">Use the *Orientation Blend* property to control the balance between rotation factors when *Orientation Mode* is set to *Blended*.</span></span> <span data-ttu-id="efb77-235">0\.0 값은 *TrackedTarget* 모드에 의해 완전히 구동되는 방향을 가지며 1.0 값은 *SurfaceNormal* 에 의해 완전히 구동되는 방향을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-235">A value of 0.0 will have orientation entirely driven by *TrackedTarget* mode and a value of 1.0 will have orientation driven entirely by *SurfaceNormal*.</span></span>

![SurfaceMagnetism 예](../../images/solver/SurfaceMagExample.png)

#### <a name="determining-what-surfaces-can-be-hit"></a><span data-ttu-id="efb77-237">비출 수 있는 표면 결정</span><span class="sxs-lookup"><span data-stu-id="efb77-237">Determining what surfaces can be hit</span></span>

<span data-ttu-id="efb77-238">GameObject에 [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) 구성 요소를 추가할 때 충돌체가 있는 경우 GameObject와 그 하위 계층을 고려하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-238">When adding a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component to a GameObject, it is important to consider the layer of the GameObject and its children, if any have colliders.</span></span> <span data-ttu-id="efb77-239">구성 요소는 다양한 형식의 광선 투사를 수행하여 어떤 표면이 자체적으로 "자성"의 성질을 가지는지 결정하는 방식으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-239">The component works by performing various types of raycasts to determine what surface to "magnet" itself against.</span></span> <span data-ttu-id="efb77-240">솔버 GameObject가 `SurfaceMagnetism`의 `MagneticSurfaces` 속성에 나열된 계층 중 하나에 충돌체를 가지고 있는 경우, 광선 투사가 스스로 비춰 GameObject가 자체 충돌체 지점에 연결될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-240">If the solver GameObject has a collider on one of the layers listed in the `MagneticSurfaces` property of `SurfaceMagnetism`, then the raycast will likely hit itself resulting in the GameObject attaching to its own collider point.</span></span> <span data-ttu-id="efb77-241">이 이상한 동작은 기본 GameObject와 모든 하위 항목을 *광선 투사 무시* 계층으로 설정하거나 `MagneticSurfaces` LayerMask 배열을 적절하게 수정하여 피할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-241">This odd behavior can be avoided by setting the main GameObject and all children to the *Ignore Raycast* layer or modifying the `MagneticSurfaces` LayerMask array appropriately.</span></span>

<span data-ttu-id="efb77-242">반대로 [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject는 `MagneticSurfaces` 속성에 나열되지 않은 계층의 표면과 충돌하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-242">Conversely, a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject will not collide with surfaces on a layer not listed in the `MagneticSurfaces` property.</span></span> <span data-ttu-id="efb77-243">일반적으로 모든 원하는 표면을 전용 계층(즉,</span><span class="sxs-lookup"><span data-stu-id="efb77-243">It is generally recommended to place all desired surfaces on a dedicated layer (i.e</span></span> <span data-ttu-id="efb77-244">*표면*)에 배치하고 `MagneticSurfaces` 속성을 이 계층로만 설정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-244">*Surfaces*) and setting the `MagneticSurfaces` property to just this layer.</span></span>  <span data-ttu-id="efb77-245">*기본값* 또는 *모두* 를 사용하면 UI 구성 요소 또는 커서가 솔버에 기여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-245">Using *default* or *everything* may result in UI components or cursors contributing to the solver.</span></span>

<span data-ttu-id="efb77-246">마지막으로 `MaxRaycastDistance` 속성 설정보다 더 멀리 있는 표면은 `SurfaceMagnetism` 광선 투사에서 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-246">Finally, surfaces farther than the `MaxRaycastDistance` property setting will be ignored by the `SurfaceMagnetism` raycasts.</span></span>

### <a name="directionalindicator"></a><span data-ttu-id="efb77-247">DirectionalIndicator</span><span class="sxs-lookup"><span data-stu-id="efb77-247">DirectionalIndicator</span></span>

<span data-ttu-id="efb77-248">[`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) 클래스는 공간에서 원하는 지점의 방향으로 자체적으로 향하는 태그얼롱 구성 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-248">The [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) class is a tag-along component that orients itself to the direction of a desired point in space.</span></span>

<span data-ttu-id="efb77-249">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler)의 *추적된 대상 유형* 이 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head)로 설정된 경우 가장 일반적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-249">Most commonly used when the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head).</span></span> <span data-ttu-id="efb77-250">이러한 방식으로 [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) 솔버가 있는 UX 구성 요소는 사용자가 공간에서 원하는 지점을 보도록 안내합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-250">In this fashion, a UX component with the [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator)  solver will direct a user to look at the desired point in space.</span></span>

<span data-ttu-id="efb77-251">공간에서 원하는 지점은 *방향 대상* 속성을 통해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-251">The desired point in space is determined via the *Directional Target* property.</span></span>

<span data-ttu-id="efb77-252">사용자가 방향 대상을 볼 수 있거나 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler)에 설정된 참조 프레임이 무엇이든 이 솔버는 그 아래에 있는 모든 [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) 구성 요소를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-252">If the directional target is viewable by the user, or whatever frame of reference is set in the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), then this solver will disable all [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) components underneath it.</span></span> <span data-ttu-id="efb77-253">표시되지 않는 경우 모든 항목이 표시기에 대해 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-253">If not viewable, then everything will be enabled on the indicator.</span></span>

<span data-ttu-id="efb77-254">표시기의 크기는 사용자가 FOV에서 *방향 대상* 을 가깝게 캡처할수록 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-254">The size of the indicator will shrink the closer the user is to capturing the *Directional Target* in their FOV.</span></span>

* <span data-ttu-id="efb77-255">*최소 표시기 배율* - 표시기 개체의 최소 배율</span><span class="sxs-lookup"><span data-stu-id="efb77-255">*Min Indicator Scale* - The minimum scale for the indicator object</span></span>
* <span data-ttu-id="efb77-256">*최대 표시기 배율* - 표시기 개체의 최대 배율</span><span class="sxs-lookup"><span data-stu-id="efb77-256">*Max Indicator Scale* - The maximum scale for the indicator object</span></span>

* <span data-ttu-id="efb77-257">*표시 배율* - *방향 대상* 지점을 볼 수 있는지 여부를 결정하는 FOV를 늘리거나 줄이는 승수</span><span class="sxs-lookup"><span data-stu-id="efb77-257">*Visibility Scale Factor* - Multiplier to increase or decrease the FOV that determines if the *Directional Target* point is viewable or not</span></span>
* <span data-ttu-id="efb77-258">*보기 오프셋* - 참조 프레임의 관점(예:</span><span class="sxs-lookup"><span data-stu-id="efb77-258">*View Offset* - From the viewpoint of the frame of reference (i.e</span></span> <span data-ttu-id="efb77-259">카메라 가능)에서 이 속성은 표시기 방향에서 개체가 뷰포트의 중심에서 떨어져 있는 정도를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-259">camera possibly), this property defines how far in the indicator direction should the object be from the center of the viewport.</span></span>

<span data-ttu-id="efb77-260">![방향 표시기 속성](../../images/solver/DirectionalIndicatorExample.png)</span><span class="sxs-lookup"><span data-stu-id="efb77-260">![Directional Indicator properties](../../images/solver/DirectionalIndicatorExample.png)</span></span>  
<span data-ttu-id="efb77-261">*방향 표시기 속성*</span><span class="sxs-lookup"><span data-stu-id="efb77-261">*Directional Indicator properties*</span></span>

<span data-ttu-id="efb77-262">![방향 표시기 장면 예](../../images/solver/DirectionalIndicatorExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="efb77-262">![Directional Indicator example scene](../../images/solver/DirectionalIndicatorExampleScene.gif)</span></span>  
<span data-ttu-id="efb77-263">*방향 표시기 장면 예(Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="efb77-263">*Directional Indicator Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span></span>

### <a name="hand-menu-with-handconstraint-and-handconstraintpalmup"></a><span data-ttu-id="efb77-264">HandConstraint 및 HandConstraintPalmUp이 있는 손 메뉴</span><span class="sxs-lookup"><span data-stu-id="efb77-264">Hand menu with HandConstraint and HandConstraintPalmUp</span></span>

![손 메뉴 UX 예](../../images/solver/MRTK_UX_HandMenu.png)

<span data-ttu-id="efb77-266">[`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 동작은 추적된 개체를 손으로 제한된 콘텐츠(예: 손 UI, 메뉴 등)에 안전한 지역으로 제한하는 솔버를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-266">The [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc).</span></span> <span data-ttu-id="efb77-267">안전 지역은 손으로 교차하지 않는 영역으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-267">Safe regions are considered areas that don't intersect with the hand.</span></span> <span data-ttu-id="efb77-268">손바닥이 사용자를 향하고 있을 때 솔버 추적 개체를 활성화하는 일반적인 동작을 보여 주기 위해 [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp)이라는 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint)의 파생 클래스도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="efb77-268">A derived class of [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) called [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</span></span>

<span data-ttu-id="efb77-269">손 제한 솔버를 사용하여 손 메뉴를 만드는 예는 [손 메뉴 페이지를 참조하세요](../hand-menu.md).</span><span class="sxs-lookup"><span data-stu-id="efb77-269">[Please see Hand Menu page](../hand-menu.md) for the examples of using Hand Constraint solver to create hand menus.</span></span>

## <a name="see-also"></a><span data-ttu-id="efb77-270">참조</span><span class="sxs-lookup"><span data-stu-id="efb77-270">See also</span></span>

* [<span data-ttu-id="efb77-271">손 추적</span><span class="sxs-lookup"><span data-stu-id="efb77-271">Hand Tracking</span></span>](../../input/hand-tracking.md)
* [<span data-ttu-id="efb77-272">응시</span><span class="sxs-lookup"><span data-stu-id="efb77-272">Gaze</span></span>](../../input/gaze.md)
